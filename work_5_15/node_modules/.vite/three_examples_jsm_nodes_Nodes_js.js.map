{
  "version": 3,
  "sources": ["../three/examples/jsm/nodes/core/constants.js", "../three/examples/jsm/nodes/core/NodeUtils.js", "../three/examples/jsm/nodes/core/Node.js", "../three/examples/jsm/nodes/core/InputNode.js", "../three/examples/jsm/nodes/core/UniformNode.js", "../three/examples/jsm/nodes/core/ArrayUniformNode.js", "../three/examples/jsm/nodes/core/VaryingNode.js", "../three/examples/jsm/nodes/core/AttributeNode.js", "../three/examples/jsm/nodes/core/BypassNode.js", "../three/examples/jsm/nodes/core/NodeCache.js", "../three/examples/jsm/nodes/core/CacheNode.js", "../three/examples/jsm/nodes/core/CodeNode.js", "../three/examples/jsm/nodes/core/ConstNode.js", "../three/examples/jsm/nodes/core/ContextNode.js", "../three/examples/jsm/nodes/core/TempNode.js", "../three/examples/jsm/nodes/core/ExpressionNode.js", "../three/examples/jsm/nodes/core/FunctionCallNode.js", "../three/examples/jsm/nodes/core/FunctionNode.js", "../three/examples/jsm/nodes/core/InstanceIndexNode.js", "../three/examples/jsm/nodes/core/NodeAttribute.js", "../three/examples/jsm/nodes/core/NodeUniform.js", "../three/examples/jsm/nodes/core/NodeVar.js", "../three/examples/jsm/nodes/core/NodeVarying.js", "../three/examples/jsm/nodes/core/NodeCode.js", "../three/examples/jsm/nodes/core/NodeKeywords.js", "../three/examples/jsm/nodes/shadernode/ShaderNodeElements.js", "../three/examples/jsm/nodes/accessors/UVNode.js", "../three/examples/jsm/nodes/accessors/TextureNode.js", "../three/examples/jsm/nodes/core/PropertyNode.js", "../three/examples/jsm/nodes/math/OperatorNode.js", "../three/examples/jsm/nodes/core/VarNode.js", "../three/examples/jsm/nodes/utils/SplitNode.js", "../three/examples/jsm/nodes/math/MathNode.js", "../three/examples/jsm/nodes/accessors/Object3DNode.js", "../three/examples/jsm/nodes/accessors/ModelNode.js", "../three/examples/jsm/nodes/accessors/CameraNode.js", "../three/examples/jsm/nodes/accessors/NormalNode.js", "../three/examples/jsm/nodes/accessors/TangentNode.js", "../three/examples/jsm/nodes/accessors/BitangentNode.js", "../three/examples/jsm/nodes/accessors/BufferNode.js", "../three/examples/jsm/nodes/accessors/ReferenceNode.js", "../three/examples/jsm/nodes/accessors/MaterialReferenceNode.js", "../three/examples/jsm/nodes/accessors/MaterialNode.js", "../three/examples/jsm/nodes/accessors/PositionNode.js", "../three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js", "../three/examples/jsm/nodes/accessors/PointUVNode.js", "../three/examples/jsm/nodes/accessors/StorageBufferNode.js", "../three/examples/jsm/nodes/accessors/UserDataNode.js", "../three/examples/jsm/nodes/display/FrontFacingNode.js", "../three/examples/jsm/nodes/gpgpu/ComputeNode.js", "../three/examples/jsm/nodes/math/CondNode.js", "../three/examples/jsm/nodes/utils/ArrayElementNode.js", "../three/examples/jsm/nodes/utils/ConvertNode.js", "../three/examples/jsm/nodes/utils/MaxMipLevelNode.js", "../three/examples/jsm/nodes/utils/JoinNode.js", "../three/examples/jsm/nodes/core/StackNode.js", "../three/examples/jsm/nodes/shadernode/ShaderNode.js", "../three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js", "../three/examples/jsm/nodes/accessors/ReflectVectorNode.js", "../three/examples/jsm/nodes/accessors/CubeTextureNode.js", "../three/examples/jsm/nodes/accessors/InstanceNode.js", "../three/examples/jsm/nodes/accessors/SkinningNode.js", "../three/examples/jsm/nodes/display/BlendModeNode.js", "../three/examples/jsm/nodes/display/ColorAdjustmentNode.js", "../three/examples/jsm/nodes/display/ColorSpaceNode.js", "../three/examples/jsm/nodes/display/NormalMapNode.js", "../three/examples/jsm/nodes/display/PosterizeNode.js", "../three/examples/jsm/nodes/display/ToneMappingNode.js", "../three/examples/jsm/nodes/display/ViewportNode.js", "../three/examples/jsm/nodes/lighting/LightingNode.js", "../three/examples/jsm/nodes/lighting/AnalyticLightNode.js", "../three/examples/jsm/nodes/lighting/LightsNode.js", "../three/examples/jsm/nodes/lighting/LightingContextNode.js", "../three/examples/jsm/nodes/utils/EquirectUVNode.js", "../three/examples/jsm/nodes/utils/MatcapUVNode.js", "../three/examples/jsm/nodes/utils/TimerNode.js", "../three/examples/jsm/nodes/utils/OscNode.js", "../three/examples/jsm/nodes/utils/RemapNode.js", "../three/examples/jsm/nodes/utils/RotateUVNode.js", "../three/examples/jsm/nodes/utils/SpecularMIPLevelNode.js", "../three/examples/jsm/nodes/utils/SpriteSheetUVNode.js", "../three/examples/jsm/nodes/utils/TriplanarTexturesNode.js", "../three/examples/jsm/nodes/geometry/RangeNode.js", "../three/examples/jsm/nodes/procedural/CheckerNode.js", "../three/examples/jsm/nodes/fog/FogNode.js", "../three/examples/jsm/nodes/fog/FogRangeNode.js", "../three/examples/jsm/nodes/fog/FogExp2Node.js", "../three/examples/jsm/nodes/functions/BSDF/F_Schlick.js", "../three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js", "../three/examples/jsm/nodes/functions/BSDF/D_GGX.js", "../three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js", "../three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js", "../three/examples/jsm/nodes/functions/BSDF/DFGApprox.js", "../three/examples/jsm/nodes/functions/light/getDistanceAttenuation.js", "../three/examples/jsm/nodes/functions/material/getGeometryRoughness.js", "../three/examples/jsm/nodes/functions/material/getRoughness.js", "../three/examples/jsm/nodes/functions/PhysicalLightingModel.js", "../three/examples/jsm/nodes/core/NodeBuilder.js", "../three/examples/jsm/nodes/core/NodeFrame.js", "../three/examples/jsm/nodes/core/NodeFunctionInput.js", "../three/examples/jsm/nodes/lighting/PointLightNode.js", "../three/examples/jsm/nodes/functions/light/getDirectionVector.js", "../three/examples/jsm/nodes/lighting/DirectionalLightNode.js", "../three/examples/jsm/nodes/lighting/SpotLightNode.js", "../three/examples/jsm/nodes/lighting/AmbientLightNode.js", "../three/examples/jsm/nodes/lighting/HemisphereLightNode.js", "../three/examples/jsm/nodes/lighting/EnvironmentNode.js", "../three/examples/jsm/nodes/lighting/AONode.js", "../three/examples/jsm/nodes/loaders/NodeLoader.js", "../three/examples/jsm/nodes/materials/NodeMaterial.js", "../three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js", "../three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js", "../three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js", "../three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js", "../three/examples/jsm/nodes/materials/PointsNodeMaterial.js", "../three/examples/jsm/nodes/materials/SpriteNodeMaterial.js", "../three/examples/jsm/nodes/materials/Materials.js", "../three/examples/jsm/nodes/loaders/NodeMaterialLoader.js", "../three/examples/jsm/nodes/loaders/NodeObjectLoader.js", "../three/examples/jsm/nodes/core/NodeParser.js", "../three/examples/jsm/nodes/core/NodeFunction.js", "../three/examples/jsm/nodes/parsers/WGSLNodeFunction.js", "../three/examples/jsm/nodes/parsers/WGSLNodeParser.js", "../three/examples/jsm/nodes/parsers/GLSLNodeFunction.js", "../three/examples/jsm/nodes/parsers/GLSLNodeParser.js", "../three/examples/jsm/nodes/materialx/lib/mx_noise.js", "../three/examples/jsm/nodes/materialx/lib/mx_hsv.js", "../three/examples/jsm/nodes/materialx/lib/mx_transform_color.js", "../three/examples/jsm/nodes/materialx/MaterialXNodes.js", "../three/examples/jsm/nodes/Nodes.js"],
  "sourcesContent": ["export const NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\nexport const NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tOBJECT: 'object'\n};\n\nexport const NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n", "import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';\n\nexport const getCacheKey = ( object ) => {\n\n\tlet cacheKey = '{';\n\n\tif ( object.isNode === true ) {\n\n\t\tcacheKey += `uuid:\"${ object.uuid }\",`;\n\n\t}\n\n\tfor ( const property of getNodesKeys( object ) ) {\n\n\t\tcacheKey += `${ property }:${ object[ property ].getCacheKey() },`;\n\n\t}\n\n\tcacheKey += '}';\n\n\treturn cacheKey;\n\n};\n\nexport const getNodesKeys = ( object ) => {\n\n\tconst props = [];\n\n\tfor ( const name in object ) {\n\n\t\tconst value = object[ name ];\n\n\t\tif ( value && value.isNode === true ) {\n\n\t\t\tprops.push( name );\n\n\t\t}\n\n\t}\n\n\treturn props;\n\n};\n\nexport const getValueType = ( value ) => {\n\n\tif ( typeof value === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeof value === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( value?.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value?.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value?.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value?.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value?.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value?.isColor === true ) {\n\n\t\treturn 'color';\n\n\t}\n\n\treturn null;\n\n};\n\nexport const getValueFromType = ( type, ...params ) => {\n\n\tconst last4 = type?.slice( - 4 );\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn 0;\n\n\t}\n\n\treturn null;\n\n};\n", "import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys, getCacheKey } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n\n\tconstructor( nodeType = null ) {\n\n\t\tthis.isNode = true;\n\n\t\tthis.nodeType = nodeType;\n\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.name;\n\n\t}\n\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetChildren() {\n\n\t\tconst children = [];\n\n\t\tfor ( const property in this ) {\n\n\t\t\tconst object = this[ property ];\n\n\t\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\t\tfor ( const child of object ) {\n\n\t\t\t\t\tif ( child?.isNode === true ) {\n\n\t\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object?.isNode === true ) {\n\n\t\t\t\tchildren.push( object );\n\n\t\t\t} else if ( typeof object === 'object' ) {\n\n\t\t\t\tfor ( const property in object ) {\n\n\t\t\t\t\tconst child = object[ property ];\n\n\t\t\t\t\tif ( child?.isNode === true ) {\n\n\t\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn children;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetUpdateType( /*builder*/ ) {\n\n\t\treturn this.updateType;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetReference( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ '_node' + childNode.id ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists\n\t\treturn null;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tnodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n\n\t\tif ( nodeData.dependenciesCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode?.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode?.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getReference( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addStack( this );\n\n\t\t/* expected return:\n\t\t\t- \"construct\"\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'construct' ) {\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true || builder.context.tempRead === false ) {\n\n\t\t\t\tproperties.initialized = true;\n\t\t\t\tproperties.outputNode = this.construct( builder );\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode?.isNode === true ) {\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined /*|| builder.context.tempRead === false*/ ) {\n\n\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeStack( this );\n\n\t\treturn result;\n\n\t}\n\n\tserialize( json ) {\n\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tif ( nodeKeys.length > 0 ) {\n\n\t\t\tconst inputNodes = {};\n\n\t\t\tfor ( const property of nodeKeys ) {\n\n\t\t\t\tinputNodes[ property ] = this[ property ].toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmeta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport default Node;\n", "import Node from './Node.js';\nimport { getValueType, getValueFromType } from './NodeUtils.js';\n\nclass InputNode extends Node {\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.isInputNode = true;\n\n\t\tthis.value = value;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value?.toArray?.() || this.value;\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = getValueFromType( data.valueType );\n\t\tthis.value = this.value?.fromArray?.( data.value ) || data.value;\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nexport default InputNode;\n", "import InputNode from './InputNode.js';\n\nclass UniformNode extends InputNode {\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isUniformNode = true;\n\n\t}\n\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, builder.shaderStage, sharedNodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\nexport default UniformNode;\n", "import UniformNode from './UniformNode.js';\n\nclass ArrayUniformNode extends UniformNode {\n\n\tconstructor( nodes = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayUniformNode = true;\n\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.nodes[ 0 ].getNodeType( builder );\n\n\t}\n\n}\n\nexport default ArrayUniformNode;\n", "import Node from './Node.js';\nimport { NodeShaderStage } from './constants.js';\n\nclass VaryingNode extends Node {\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { name, node } = this;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeVarying = builder.getVaryingFromNode( this, type );\n\n\t\t// this property can be used to check if the varying can be optimized for a var\n\t\tnodeVarying.needsInterpolation ||= builder.shaderStage === 'fragment';\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVarying.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeVarying, NodeShaderStage.VERTEX );\n\n\t\t// force node run in vertex stage\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, node, type, propertyName );\n\n\t\treturn builder.getPropertyName( nodeVarying );\n\n\t}\n\n}\n\nexport default VaryingNode;\n", "import Node from './Node.js';\nimport VaryingNode from './VaryingNode.js';\n\nclass AttributeNode extends Node {\n\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\tlet nodeType = super.getNodeType( builder );\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromLength( attribute.itemSize );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, nodeType );\n\n\t\t\tif ( builder.isShaderStage( 'vertex' ) ) {\n\n\t\t\t\treturn nodeAttribute.name;\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = new VaryingNode( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeAttribute.type );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `Attribute \"${ attributeName }\" not found.` );\n\n\t\t\treturn builder.getConst( nodeType );\n\n\t\t}\n\n\t}\n\n}\n\nexport default AttributeNode;\n", "import Node from './Node.js';\n\nclass BypassNode extends Node {\n\n\tconstructor( returnNode, callNode ) {\n\n\t\tsuper();\n\n\t\tthis.isBypassNode = true;\n\n\t\tthis.outputNode = returnNode;\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addFlowCode( snippet );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder, output );\n\n\t}\n\n}\n\nexport default BypassNode;\n", "let id = 0;\n\nclass NodeCache {\n\n\tconstructor() {\n\n\t\tthis.id = id ++;\n\t\tthis.nodesData = new WeakMap();\n\n\t}\n\n\tgetNodeData( node ) {\n\n\t\treturn this.nodesData.get( node );\n\n\t}\n\n\tsetNodeData( node, data ) {\n\n\t\tthis.nodesData.set( node, data );\n\n\t}\n\n}\n\nexport default NodeCache;\n", "import Node from './Node.js';\nimport NodeCache from './NodeCache.js';\n\nclass CacheNode extends Node {\n\n\tconstructor( node, cache = new NodeCache() ) {\n\n\t\tsuper();\n\n\t\tthis.isCacheNode = true;\n\n\t\tthis.node = node;\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\n\t\tbuilder.setCache( this.cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport default CacheNode;\n", "import Node from './Node.js';\n\nclass CodeNode extends Node {\n\n\tconstructor( code = '', includes = [] ) {\n\n\t\tsuper( 'code' );\n\n\t\tthis.isCodeNode = true;\n\n\t\tthis.code = code;\n\n\t\tthis._includes = includes;\n\n\t}\n\n\tsetIncludes( includes ) {\n\n\t\tthis._includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this._includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n}\n\nexport default CodeNode;\n", "import InputNode from './InputNode.js';\n\nclass ConstNode extends InputNode {\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isConstNode = true;\n\n\t}\n\n\tgenerateConst( builder ) {\n\n\t\treturn builder.getConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\nexport default ConstNode;\n", "import Node from './Node.js';\n\nclass ContextNode extends Node {\n\n\tconstructor( node, context = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isContextNode = true;\n\n\t\tthis.node = node;\n\t\tthis.context = context;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.context } );\n\n\t\tconst node = this.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn node;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.context } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nexport default ContextNode;\n", "import Node from './Node.js';\n\nclass TempNode extends Node {\n\n\tconstructor( type ) {\n\n\t\tsuper( type );\n\n\t\tthis.isTempNode = true;\n\n\t}\n\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).dependenciesCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( builder.context.tempRead !== false && nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( builder.context.tempWrite !== false && type !== 'void ' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\nexport default TempNode;\n", "import TempNode from './TempNode.js';\n\nclass ExpressionNode extends TempNode {\n\n\tconstructor( snipped = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.snipped = snipped;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snipped = this.snipped;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addFlowCode( snipped );\n\n\t\t} else {\n\n\t\t\treturn `( ${ snipped } )`;\n\n\t\t}\n\n\t}\n\n}\n\nexport default ExpressionNode;\n", "import TempNode from './TempNode.js';\n\nclass FunctionCallNode extends TempNode {\n\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.functionNode = functionNode;\n\t\tthis.parameters = parameters;\n\n\t}\n\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tconst inputNode = inputs[ i ];\n\t\t\t\tconst node = parameters[ i ];\n\n\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nexport default FunctionCallNode;\n", "import CodeNode from './CodeNode.js';\nimport FunctionCallNode from './FunctionCallNode.js';\n\nclass FunctionNode extends CodeNode {\n\n\tconstructor( code = '', includes = [] ) {\n\n\t\tsuper( code, includes );\n\n\t\tthis.keywords = {};\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tcall( parameters = {} ) {\n\n\t\treturn new FunctionCallNode( this, parameters );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tlet code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tconst keywords = this.keywords;\n\t\tconst keywordsProperties = Object.keys( keywords );\n\n\t\tif ( keywordsProperties.length > 0 ) {\n\n\t\t\tfor ( const property of keywordsProperties ) {\n\n\t\t\t\tconst propertyRegExp = new RegExp( `\\\\b${property}\\\\b`, 'g' );\n\t\t\t\tconst nodeProperty = keywords[ property ].build( builder, 'property' );\n\n\t\t\t\tcode = code.replace( propertyRegExp, nodeProperty );\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeCode.code = code;\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nexport default FunctionNode;\n", "import Node from './Node.js';\n\nclass InstanceIndexNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'uint' );\n\n\t\tthis.isInstanceIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getInstanceIndex();\n\n\t}\n\n}\n\nexport default InstanceIndexNode;\n", "class NodeAttribute {\n\n\tconstructor( name, type ) {\n\n\t\tthis.isNodeAttribute = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nexport default NodeAttribute;\n", "class NodeUniform {\n\n\tconstructor( name, type, node, needsUpdate = undefined ) {\n\n\t\tthis.isNodeUniform = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node;\n\t\tthis.needsUpdate = needsUpdate;\n\n\t}\n\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n}\n\nexport default NodeUniform;\n", "class NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tthis.isNodeVar = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nexport default NodeVar;\n", "import NodeVar from './NodeVar.js';\n\nclass NodeVarying extends NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tsuper( name, type );\n\n\t\tthis.needsInterpolation = false;\n\n\t\tthis.isNodeVarying = true;\n\n\t}\n\n}\n\nexport default NodeVarying;\n", "class NodeCode {\n\n\tconstructor( name, type, code = '' ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.code = code;\n\n\t\tObject.defineProperty( this, 'isNodeCode', { value: true } );\n\n\t}\n\n}\n\nexport default NodeCode;\n", "class NodeKeywords {\n\n\tconstructor() {\n\n\t\tthis.keywords = [];\n\t\tthis.nodes = [];\n\t\tthis.keywordsCallback = {};\n\n\t}\n\n\tgetNode( name ) {\n\n\t\tlet node = this.nodes[ name ];\n\n\t\tif ( node === undefined && this.keywordsCallback[ name ] !== undefined ) {\n\n\t\t\tnode = this.keywordsCallback[ name ]( name );\n\n\t\t\tthis.nodes[ name ] = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\taddKeyword( name, callback ) {\n\n\t\tthis.keywords.push( name );\n\t\tthis.keywordsCallback[ name ] = callback;\n\n\t\treturn this;\n\n\t}\n\n\tparse( code ) {\n\n\t\tconst keywordNames = this.keywords;\n\n\t\tconst regExp = new RegExp( `\\\\b${keywordNames.join( '\\\\b|\\\\b' )}\\\\b`, 'g' );\n\n\t\tconst codeKeywords = code.match( regExp );\n\n\t\tconst keywordNodes = [];\n\n\t\tif ( codeKeywords !== null ) {\n\n\t\t\tfor ( const keyword of codeKeywords ) {\n\n\t\t\t\tconst node = this.getNode( keyword );\n\n\t\t\t\tif ( node !== undefined && keywordNodes.indexOf( node ) === - 1 ) {\n\n\t\t\t\t\tkeywordNodes.push( node );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn keywordNodes;\n\n\t}\n\n\tinclude( builder, code ) {\n\n\t\tconst keywordNodes = this.parse( code );\n\n\t\tfor ( const keywordNode of keywordNodes ) {\n\n\t\t\tkeywordNode.build( builder );\n\n\t\t}\n\n\t}\n\n}\n\nexport default NodeKeywords;\n", "// accessors\nimport CubeTextureNode from '../accessors/CubeTextureNode.js';\nimport InstanceNode from '../accessors/InstanceNode.js';\nimport ReflectVectorNode from '../accessors/ReflectVectorNode.js';\nimport SkinningNode from '../accessors/SkinningNode.js';\n\n// display\nimport BlendModeNode from '../display/BlendModeNode.js';\nimport ColorAdjustmentNode from '../display/ColorAdjustmentNode.js';\nimport ColorSpaceNode from '../display/ColorSpaceNode.js';\nimport NormalMapNode from '../display/NormalMapNode.js';\nimport PosterizeNode from '../display/PosterizeNode.js';\nimport ToneMappingNode from '../display/ToneMappingNode.js';\nimport ViewportNode from '../display/ViewportNode.js';\n\n// lighting\nimport LightsNode from '../lighting/LightsNode.js';\n//import LightingNode from '../lighting/LightingNode.js';\nimport LightingContextNode from '../lighting/LightingContextNode.js';\n\n// utils\nimport EquirectUVNode from '../utils/EquirectUVNode.js';\nimport MatcapUVNode from '../utils/MatcapUVNode.js';\nimport OscNode from '../utils/OscNode.js';\nimport RemapNode from '../utils/RemapNode.js';\nimport RotateUVNode from '../utils/RotateUVNode.js';\nimport SpecularMIPLevelNode from '../utils/SpecularMIPLevelNode.js';\nimport SpriteSheetUVNode from '../utils/SpriteSheetUVNode.js';\nimport TimerNode from '../utils/TimerNode.js';\nimport TriplanarTexturesNode from '../utils/TriplanarTexturesNode.js';\n\n// geometry\nimport RangeNode from '../geometry/RangeNode.js';\n\n// procedural\nimport CheckerNode from '../procedural/CheckerNode.js';\n\n// fog\nimport FogNode from '../fog/FogNode.js';\nimport FogRangeNode from '../fog/FogRangeNode.js';\nimport FogExp2Node from '../fog/FogExp2Node.js';\n\n// shader node utils\nimport { nodeObject, nodeProxy, nodeImmutable } from './ShaderNode.js';\n\n//\n// Node Material Shader Syntax\n//\n\n// shader node base\n\nexport * from './ShaderNodeBaseElements.js';\n\n// functions\n\nexport { default as BRDF_GGX } from '../functions/BSDF/BRDF_GGX.js'; // see https://github.com/tc39/proposal-export-default-from\nexport { default as BRDF_Lambert } from '../functions/BSDF/BRDF_Lambert.js';\nexport { default as D_GGX } from '../functions/BSDF/D_GGX.js';\nexport { default as DFGApprox } from '../functions/BSDF/DFGApprox.js';\nexport { default as F_Schlick } from '../functions/BSDF/F_Schlick.js';\nexport { default as V_GGX_SmithCorrelated } from '../functions/BSDF/V_GGX_SmithCorrelated.js';\n\nexport { default as getDistanceAttenuation } from '../functions/light/getDistanceAttenuation.js';\n\nexport { default as getGeometryRoughness } from '../functions/material/getGeometryRoughness.js';\nexport { default as getRoughness } from '../functions/material/getRoughness.js';\n\nexport { default as PhysicalLightingModel } from '../functions/PhysicalLightingModel.js';\n\n// accessors\n\nexport const cubeTexture = nodeProxy( CubeTextureNode );\n\nexport const instance = nodeProxy( InstanceNode );\n\nexport const reflectVector = nodeImmutable( ReflectVectorNode );\n\nexport const skinning = nodeProxy( SkinningNode );\n\n// display\n\nexport const burn = nodeProxy( BlendModeNode, BlendModeNode.BURN );\nexport const dodge = nodeProxy( BlendModeNode, BlendModeNode.DODGE );\nexport const overlay = nodeProxy( BlendModeNode, BlendModeNode.OVERLAY );\nexport const screen = nodeProxy( BlendModeNode, BlendModeNode.SCREEN );\n\nexport const saturation = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.SATURATION );\nexport const vibrance = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE );\nexport const hue = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.HUE );\n\nexport const colorSpace = ( node, encoding ) => nodeObject( new ColorSpaceNode( null, nodeObject( node ) ).fromEncoding( encoding ) );\nexport const normalMap = nodeProxy( NormalMapNode );\nexport const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\n\nexport const posterize = nodeProxy( PosterizeNode );\n\nexport const viewportCoordinate = nodeImmutable( ViewportNode, ViewportNode.COORDINATE );\nexport const viewportResolution = nodeImmutable( ViewportNode, ViewportNode.RESOLUTION );\nexport const viewportTopLeft = nodeImmutable( ViewportNode, ViewportNode.TOP_LEFT );\nexport const viewportBottomLeft = nodeImmutable( ViewportNode, ViewportNode.BOTTOM_LEFT );\nexport const viewportTopRight = nodeImmutable( ViewportNode, ViewportNode.TOP_RIGHT );\nexport const viewportBottomRight = nodeImmutable( ViewportNode, ViewportNode.BOTTOM_RIGHT );\n\n// lighting\n\n//export const lighting = nodeProxy( LightingNode ); // abstract\n//export const light; // still needs to be added\nexport const lights = ( lights ) => nodeObject( new LightsNode().fromLights( lights ) );\nexport const lightingContext = nodeProxy( LightingContextNode );\n\n// utils\n\nexport const matcapUV = nodeImmutable( MatcapUVNode );\nexport const equirectUV = nodeProxy( EquirectUVNode );\n\nexport const specularMIPLevel = nodeProxy( SpecularMIPLevelNode );\n\nexport const oscSine = nodeProxy( OscNode, OscNode.SINE );\nexport const oscSquare = nodeProxy( OscNode, OscNode.SQUARE );\nexport const oscTriangle = nodeProxy( OscNode, OscNode.TRIANGLE );\nexport const oscSawtooth = nodeProxy( OscNode, OscNode.SAWTOOTH );\n\nexport const remap = nodeProxy( RemapNode, null, null, { doClamp: false } );\nexport const remapClamp = nodeProxy( RemapNode );\n\nexport const rotateUV = nodeProxy( RotateUVNode );\n\nexport const spritesheetUV = nodeProxy( SpriteSheetUVNode );\n\n// @TODO: add supports to use node in timeScale\nexport const timerLocal = ( timeScale, value = 0 ) => nodeObject( new TimerNode( TimerNode.LOCAL, timeScale, value ) );\nexport const timerGlobal = ( timeScale, value = 0 ) => nodeObject( new TimerNode( TimerNode.GLOBAL, timeScale, value ) );\nexport const timerDelta = ( timeScale, value = 0 ) => nodeObject( new TimerNode( TimerNode.DELTA, timeScale, value ) );\nexport const frameId = nodeImmutable( TimerNode, TimerNode.FRAME );\n\nexport const triplanarTextures = nodeProxy( TriplanarTexturesNode );\nexport const triplanarTexture = ( texture, ...params ) => triplanarTextures( texture, texture, texture, ...params );\n\n// geometry\n\nexport const range = ( min, max ) => nodeObject( new RangeNode( min, max ) );\n\n// procedural\n\nexport const checker = nodeProxy( CheckerNode );\n\n// fog\n\nexport const fog = nodeProxy( FogNode );\nexport const rangeFog = nodeProxy( FogRangeNode );\nexport const exp2Fog = nodeProxy( FogExp2Node );\n", "import AttributeNode from '../core/AttributeNode.js';\n\nclass UVNode extends AttributeNode {\n\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec2' );\n\n\t\tthis.isUVNode = true;\n\n\t\tthis.index = index;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'uv' + ( index > 0 ? index + 1 : '' );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\nexport default UVNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport UVNode from './UVNode.js';\n\nlet defaultUV;\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, 'vec4' );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\tdefaultUV ||= new UVNode();\n\n\t\treturn defaultUV;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUVNode ) {\n\n\t\t\tuvNode = builder.context.getUVNode( this )\n\n\t\t}\n\n\t\tuvNode ||= this.getDefaultUV();\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getSamplerLevelNode ) {\n\n\t\t\tlevelNode = builder.context.getSamplerLevelNode( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode( this, levelNode ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { uvNode, levelNode } = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'texture' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst uvSnippet = uvNode.build( builder, 'vec2' );\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, 'vec4' );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tlet snippet = null;\n\n\t\t\t\tif ( levelNode?.isNode === true) {\n\n\t\t\t\t\tconst levelSnippet = levelNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getTextureLevel( textureProperty, uvSnippet, levelSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getTexture( textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\treturn builder.format( propertyName, 'vec4', output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n}\n\nexport default TextureNode;\n", "import Node from './Node.js';\n\nclass PropertyNode extends Node {\n\n\tconstructor( name = null, nodeType = 'vec4' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.name = name;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeVary = builder.getVarFromNode( this, this.getNodeType( builder ) );\n\t\tconst name = this.name;\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVary.name = name;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVary );\n\n\t}\n\n}\n\nexport default PropertyNode;\n", "import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tthis.op = op;\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalBNode = bNode;\n\n\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\tfinalBNode = new OperatorNode( op, finalBNode, params[ i ] );\n\n\t\t\t}\n\n\t\t\tbNode = finalBNode;\n\n\t\t}\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\n\t}\n\n\thasDependencies( builder ) {\n\n\t\treturn this.op !== '=' ? super.hasDependencies( builder ) : false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = bNode.getNodeType( builder );\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '=' || op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = builder.getTypeLength( output );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\treturn typeB;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = bNode.getNodeType( builder );\n\n\t\t\tif ( op === '=' ) {\n\n\t\t\t\ttypeB = typeA;\n\n\t\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = bNode.build( builder, typeB );\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '=' ) {\n\n\t\t\t\tbuilder.addFlowCode( `${a} ${this.op} ${b}` );\n\n\t\t\t\treturn a;\n\n\t\t\t} else if ( op === '<' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThan' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else if ( op === '>=' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThanEqual' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `( ${a} ${this.op} ${b} )`, type, output );\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\treturn builder.format( `${a} ${this.op} ${b}`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nexport default OperatorNode;\n", "import Node from './Node.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass VarNode extends Node {\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t}\n\n\top( op, ...params ) {\n\n\t\tthis.node = new OperatorNode( op, this.node, ...params );\n\n\t\treturn this;\n\n\t}\n\n\tassign( ...params ) {\n\n\t\treturn this.op( '=', ...params );\n\n\t}\n\n\tadd( ...params ) {\n\n\t\treturn this.op( '+', ...params );\n\n\t}\n\n\tsub( ...params ) {\n\n\t\treturn this.op( '-', ...params );\n\n\t}\n\n\tmul( ...params ) {\n\n\t\treturn this.op( '*', ...params );\n\n\t}\n\n\tdiv( ...params ) {\n\n\t\treturn this.op( '/', ...params );\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst node = this.node;\n\t\tconst name = this.name;\n\n\t\tif ( name === null && node.isTempNode === true ) {\n\n\t\t\treturn node.build( builder );\n\n\t\t}\n\n\t\tconst type = builder.getVectorType( this.getNodeType( builder ) );\n\n\t\tconst snippet = node.build( builder, type );\n\t\tconst nodeVar = builder.getVarFromNode( this, type );\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVar.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nexport default VarNode;\n", "import Node from '../core/Node.js';\nimport { vector } from '../core/NodeBuilder.js';\n\nconst vectorComponents = 'xyzw';\n\nclass SplitNode extends Node {\n\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.components = components;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vector.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength() );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === vectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nexport default SplitNode;\n", "import TempNode from '../core/TempNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport OperatorNode from './OperatorNode.js';\n\nclass MathNode extends TempNode {\n\n\t// 1 input\n\n\tstatic RADIANS = 'radians';\n\tstatic DEGREES = 'degrees';\n\tstatic EXP = 'exp';\n\tstatic EXP2 = 'exp2';\n\tstatic LOG = 'log';\n\tstatic LOG2 = 'log2';\n\tstatic SQRT = 'sqrt';\n\tstatic INVERSE_SQRT = 'inversesqrt';\n\tstatic FLOOR = 'floor';\n\tstatic CEIL = 'ceil';\n\tstatic NORMALIZE = 'normalize';\n\tstatic FRACT = 'fract';\n\tstatic SIN = 'sin';\n\tstatic COS = 'cos';\n\tstatic TAN = 'tan';\n\tstatic ASIN = 'asin';\n\tstatic ACOS = 'acos';\n\tstatic ATAN = 'atan';\n\tstatic ABS = 'abs';\n\tstatic SIGN = 'sign';\n\tstatic LENGTH = 'length';\n\tstatic NEGATE = 'negate';\n\tstatic INVERT = 'invert';\n\tstatic DFDX = 'dFdx';\n\tstatic DFDY = 'dFdy';\n\tstatic ROUND = 'round';\n\tstatic RECIPROCAL = 'reciprocal';\n\n\t// 2 inputs\n\n\tstatic ATAN2 = 'atan2';\n\tstatic MIN = 'min';\n\tstatic MAX = 'max';\n\tstatic MOD = 'mod';\n\tstatic STEP = 'step';\n\tstatic REFLECT = 'reflect';\n\tstatic DISTANCE = 'distance';\n\tstatic DOT = 'dot';\n\tstatic CROSS = 'cross';\n\tstatic POW = 'pow';\n\tstatic TRANSFORM_DIRECTION = 'transformDirection';\n\n\t// 3 inputs\n\n\tstatic MIX = 'mix';\n\tstatic CLAMP = 'clamp';\n\tstatic REFRACT = 'refract';\n\tstatic SMOOTHSTEP = 'smoothstep';\n\tstatic FACEFORWARD = 'faceforward';\n\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\t\tthis.cNode = cNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst isWebGL = builder.renderer.isWebGLRenderer === true;\n\n\t\tif ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tB.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\n\n\t\t\t} else {\n\n\t\t\t\ttA = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tA.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\n\n\t\t\t}\n\n\t\t\tconst mulNode = new SplitNode( new OperatorNode( '*', tA, tB ), 'xyz' );\n\n\t\t\treturn new MathNode( MathNode.NORMALIZE, mulNode ).build( builder );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( -' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.INVERT ) {\n\n\t\t\treturn builder.format( '( 1.0 - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\treturn builder.format( '( 1.0 / ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\n\t\t\t\tif ( c !== null ) {\n\n\t\t\t\t\tparams.push( b.build( builder, inputType ), c.build( builder, inputType ) );\n\n\t\t\t\t} else if ( b !== null ) {\n\n\t\t\t\t\tparams.push( b.build( builder, inputType ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\nexport default MathNode;\n", "import { Vector3 } from 'three';\nimport Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass Object3DNode extends Node {\n\n\tstatic VIEW_MATRIX = 'viewMatrix';\n\tstatic NORMAL_MATRIX = 'normalMatrix';\n\tstatic WORLD_MATRIX = 'worldMatrix';\n\tstatic POSITION = 'position';\n\tstatic VIEW_POSITION = 'viewPosition';\n\n\tconstructor( scope = Object3DNode.VIEW_MATRIX, object3d = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.object3d = object3d;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\treturn 'mat3';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\tuniformNode.value = object.modelViewMatrix;\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\tuniformNode.value = object.normalMatrix;\n\n\t\t} else if ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat3';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default Object3DNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass ModelNode extends Object3DNode {\n\n\tconstructor( scope = ModelNode.VIEW_MATRIX ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nexport default ModelNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass CameraNode extends Object3DNode {\n\n\tstatic PROJECTION_MATRIX = 'projectionMatrix';\n\n\tconstructor( scope = CameraNode.POSITION ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t}\n\n\t\treturn super.getNodeType( builder );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst camera = frame.camera;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\tuniformNode.value = camera.projectionMatrix;\n\n\t\t} else if ( scope === CameraNode.VIEW_MATRIX ) {\n\n\t\t\tuniformNode.value = camera.matrixWorldInverse;\n\n\t\t} else {\n\n\t\t\tthis.object3d = camera;\n\n\t\t\tsuper.update( frame );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nexport default CameraNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryingNode from '../core/VaryingNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\n\nclass NormalNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic VIEW = 'view';\n\tstatic WORLD = 'world';\n\n\tconstructor( scope = NormalNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `normal-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === NormalNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'normal', 'vec3' );\n\n\t\t} else if ( scope === NormalNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryingNode( new NormalNode( NormalNode.GEOMETRY ) );\n\n\t\t} else if ( scope === NormalNode.VIEW ) {\n\n\t\t\tconst vertexNode = new OperatorNode( '*', new ModelNode( ModelNode.NORMAL_MATRIX ), new NormalNode( NormalNode.LOCAL ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNode ) );\n\n\t\t} else if ( scope === NormalNode.WORLD ) {\n\n\t\t\t// To use INVERSE_TRANSFORM_DIRECTION only inverse the param order like this: MathNode( ..., Vector, Matrix );\n\t\t\tconst vertexNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new NormalNode( NormalNode.VIEW ), new CameraNode( CameraNode.VIEW_MATRIX ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default NormalNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryingNode from '../core/VaryingNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\nimport SplitNode from '../utils/SplitNode.js';\n\nclass TangentNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic VIEW = 'view';\n\tstatic WORLD = 'world';\n\n\tconstructor( scope = TangentNode.LOCAL ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `tangent-${this.scope}`;\n\n\t}\n\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === TangentNode.GEOMETRY ) {\n\n\t\t\treturn 'vec4';\n\n\t\t}\n\n\t\treturn 'vec3';\n\n\t}\n\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === TangentNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'tangent', 'vec4' );\n\n\t\t} else if ( scope === TangentNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryingNode( new SplitNode( new TangentNode( TangentNode.GEOMETRY ), 'xyz' ) );\n\n\t\t} else if ( scope === TangentNode.VIEW ) {\n\n\t\t\tconst vertexNode = new SplitNode( new OperatorNode( '*', new ModelNode( ModelNode.VIEW_MATRIX ), new TangentNode( TangentNode.LOCAL ) ), 'xyz' );\n\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNode ) );\n\n\t\t} else if ( scope === TangentNode.WORLD ) {\n\n\t\t\tconst vertexNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new TangentNode( TangentNode.VIEW ), new CameraNode( CameraNode.VIEW_MATRIX ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default TangentNode;\n", "import Node from '../core/Node.js';\nimport VaryingNode from '../core/VaryingNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport NormalNode from './NormalNode.js';\nimport TangentNode from './TangentNode.js';\n\nclass BitangentNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic VIEW = 'view';\n\tstatic WORLD = 'world';\n\n\tconstructor( scope = BitangentNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `bitangent-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tconst crossNormalTangent = new MathNode( MathNode.CROSS, new NormalNode( scope ), new TangentNode( scope ) );\n\t\tconst tangentW = new SplitNode( new TangentNode( TangentNode.GEOMETRY ), 'w' );\n\t\tconst vertexNode = new SplitNode( new OperatorNode( '*', crossNormalTangent, tangentW ), 'xyz' );\n\n\t\tconst outputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexNode ) );\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default BitangentNode;\n", "import UniformNode from '../core/UniformNode.js';\n\nclass BufferNode extends UniformNode {\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.isBufferNode = true;\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\nexport default BufferNode;\n", "import Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass ReferenceNode extends Node {\n\n\tconstructor( property, uniformType, object = null ) {\n\n\t\tsuper();\n\n\t\tthis.property = property;\n\n\t\tthis.uniformType = uniformType;\n\n\t\tthis.object = object;\n\n\t\tthis.node = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis.setNodeType( uniformType );\n\n\t}\n\n\tsetNodeType( uniformType ) {\n\n\t\tthis.node = new UniformNode( null, uniformType );\n\t\tthis.nodeType = uniformType;\n\n\t\tif ( uniformType === 'color' ) {\n\n\t\t\tthis.nodeType = 'vec3';\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tthis.nodeType = 'vec4';\n\n\t\t}\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.uniformType;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object !== null ? this.object : frame.object;\n\t\tconst value = object[ this.property ];\n\n\t\tthis.node.value = value;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.node.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n}\n\nexport default ReferenceNode;\n", "import ReferenceNode from './ReferenceNode.js';\n\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\tthis.material = material;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.object = this.material !== null ? this.material : frame.material;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nexport default MaterialReferenceNode;\n", "import Node from '../core/Node.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MaterialReferenceNode from './MaterialReferenceNode.js';\nimport TextureNode from './TextureNode.js';\nimport SplitNode from '../utils/SplitNode.js';\n\nclass MaterialNode extends Node {\n\n\tstatic ALPHA_TEST = 'alphaTest';\n\tstatic COLOR = 'color';\n\tstatic OPACITY = 'opacity';\n\tstatic ROUGHNESS = 'roughness';\n\tstatic METALNESS = 'metalness';\n\tstatic EMISSIVE = 'emissive';\n\tstatic ROTATION = 'rotation';\n\n\tconstructor( scope = MaterialNode.COLOR ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst material = builder.context.material;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\treturn material.map !== null ? 'vec4' : 'vec3';\n\n\t\t} else if ( scope === MaterialNode.OPACITY || scope === MaterialNode.ROTATION ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS ) {\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.ALPHA_TEST ) {\n\n\t\t\tnode = new MaterialReferenceNode( 'alphaTest', 'float' );\n\n\t\t} else if ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = new MaterialReferenceNode( 'color', 'color' );\n\n\t\t\tif ( material.map?.isTexture === true ) {\n\n\t\t\t\t//new MaterialReferenceNode( 'map', 'texture' )\n\t\t\t\tconst map = new TextureNode( material.map );\n\n\t\t\t\tnode = new OperatorNode( '*', colorNode, map );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = new MaterialReferenceNode( 'opacity', 'float' );\n\n\t\t\tif ( material.alphaMap?.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', opacityNode, new MaterialReferenceNode( 'alphaMap', 'texture' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) {\n\n\t\t\tconst roughnessNode = new MaterialReferenceNode( 'roughness', 'float' );\n\n\t\t\tif ( material.roughnessMap?.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', roughnessNode, new SplitNode( new TextureNode( material.roughnessMap ), 'g' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = new MaterialReferenceNode( 'metalness', 'float' );\n\n\t\t\tif ( material.metalnessMap?.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', metalnessNode, new SplitNode( new TextureNode( material.metalnessMap ), 'b' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveNode = new MaterialReferenceNode( 'emissive', 'color' );\n\n\t\t\tif ( material.emissiveMap?.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', emissiveNode, new TextureNode( material.emissiveMap ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROTATION ) {\n\n\t\t\tnode = new MaterialReferenceNode( 'rotation', 'float' );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = new MaterialReferenceNode( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport default MaterialNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryingNode from '../core/VaryingNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass PositionNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic WORLD = 'world';\n\tstatic WORLD_DIRECTION = 'worldDirection';\n\tstatic VIEW = 'view';\n\tstatic VIEW_DIRECTION = 'viewDirection';\n\n\tconstructor( scope = PositionNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `position-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === PositionNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'position', 'vec3' );\n\n\t\t} else if ( scope === PositionNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryingNode( new PositionNode( PositionNode.GEOMETRY ) );\n\n\t\t} else if ( scope === PositionNode.WORLD ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new ModelNode( ModelNode.WORLD_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryingNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW ) {\n\n\t\t\tconst vertexPositionNode = new OperatorNode( '*', new ModelNode( ModelNode.VIEW_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryingNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW_DIRECTION ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.VIEW ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexPositionNode ) );\n\n\t\t} else if ( scope === PositionNode.WORLD_DIRECTION ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.WORLD ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexPositionNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default PositionNode;\n", "import Node from '../core/Node.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport PositionNode from '../accessors/PositionNode.js';\n\nclass ModelViewProjectionNode extends Node {\n\n\tconstructor( position = new PositionNode() ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.position = position;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst position = this.position;\n\n\t\tconst mvpMatrix = new OperatorNode( '*', new CameraNode( CameraNode.PROJECTION_MATRIX ), new ModelNode( ModelNode.VIEW_MATRIX ) );\n\t\tconst mvpNode = new OperatorNode( '*', mvpMatrix, position );\n\n\t\treturn mvpNode.build( builder );\n\n\t}\n\n}\n\nexport default ModelViewProjectionNode;\n", "import Node from '../core/Node.js';\n\nclass PointUVNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.isPointUVNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\nexport default PointUVNode;\n", "import BufferNode from './BufferNode.js';\n\nclass StorageBufferNode extends BufferNode {\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType, bufferCount );\n\n\t\tthis.isStorageBufferNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageBuffer';\n\n\t}\n\n}\n\nexport default StorageBufferNode;\n", "import ReferenceNode from './ReferenceNode.js';\n\nclass UserDataNode extends ReferenceNode {\n\n\tconstructor( property, inputType, userData = null ) {\n\n\t\tsuper( property, inputType, userData );\n\n\t\tthis.userData = userData;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.object = this.userData !== null ? this.userData : frame.object.userData;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nexport default UserDataNode;\n", "import Node from '../core/Node.js';\n\nclass FrontFacingNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\nexport default FrontFacingNode;\n", "import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass ComputeNode extends Node {\n\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.isComputeNode = true;\n\n\t\tthis.computeNode = computeNode;\n\n\t\tthis.count = count;\n\t\tthis.workgroupSize = workgroupSize;\n\t\tthis.dispatchCount = 0;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\tonInit() { }\n\n\tupdate( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addFlowCode( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport default ComputeNode;\n", "import Node from '../core/Node.js';\nimport PropertyNode from '../core/PropertyNode.js';\nimport ContextNode from '../core/ContextNode.js';\n\nclass CondNode extends Node {\n\n\tconstructor( condNode, ifNode, elseNode ) {\n\n\t\tsuper();\n\n\t\tthis.condNode = condNode;\n\n\t\tthis.ifNode = ifNode;\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst ifType = this.ifNode.getNodeType( builder );\n\t\tconst elseType = this.elseNode.getNodeType( builder );\n\n\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\treturn elseType;\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst context = { tempWrite: false };\n\t\tconst nodeProperty = new PropertyNode( null, type ).build( builder );\n\n\t\tconst nodeSnippet = new ContextNode( this.condNode/*, context*/ ).build( builder, 'bool' ),\n\t\t\tifSnippet = new ContextNode( this.ifNode, context ).build( builder, type ),\n\t\t\telseSnippet = new ContextNode( this.elseNode, context ).build( builder, type );\n\n\t\tbuilder.addFlowCode( `if ( ${nodeSnippet} ) {\n\n\\t\\t${nodeProperty} = ${ifSnippet};\n\n\\t} else {\n\n\\t\\t${nodeProperty} = ${elseSnippet};\n\n\\t}` );\n\n\t\treturn nodeProperty;\n\n\t}\n\n}\n\nexport default CondNode;\n", "import TempNode from '../core/Node.js';\n\nclass ArrayElementNode extends TempNode {\n\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.indexNode = indexNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\n\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\n\n\t}\n\n}\n\nexport default ArrayElementNode;\n", "import Node from '../core/Node.js';\n\nclass ConvertNode extends Node {\n\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nexport default ConvertNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass MaxMipLevelNode extends UniformNode {\n\n\tconstructor( textureNode ) {\n\n\t\tsuper( 0 );\n\n\t\tthis.textureNode = textureNode;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textureNode.value;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.texture;\n\t\tconst images = texture.images;\n\t\tconst image = ( images && images.length > 0 ) ? ( images[ 0 ]?.image || images[ 0 ] ) : texture.image;\n\n\t\tif ( image?.width !== undefined ) {\n\n\t\t\tconst { width, height } = image;\n\n\t\t\tthis.value = Math.log2( Math.max( width, height ) );\n\n\t\t}\n\n\t}\n\n}\n\nexport default MaxMipLevelNode;\n", "import TempNode from '../core/Node.js';\n\nclass JoinNode extends TempNode {\n\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tconst inputSnippet = input.build( builder );\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nexport default JoinNode;\n", "import Node from './Node.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass StackNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.nodes = [];\n\t\tthis.outputNode = null;\n\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tassign( targetNode, sourceValue ) {\n\n\t\tthis.nodes.push( new OperatorNode( '=', targetNode, sourceValue ) );\n\n\t\treturn this;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n}\n\nexport default StackNode;\n", "import Node from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport StackNode from '../core/StackNode.js';\nimport { getValueFromType } from '../core/NodeUtils.js';\n\nimport * as NodeElements from './ShaderNodeElements.js';\n\nconst shaderNodeHandler = {\n\n\tconstruct( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget: function ( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = prop\n\t\t\t\t\t.replace( /r|s/g, 'x' )\n\t\t\t\t\t.replace( /g|t/g, 'y' )\n\t\t\t\t\t.replace( /b|p/g, 'z' )\n\t\t\t\t\t.replace( /a|q/g, 'w' );\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t} else if ( NodeElements[ prop ] ) {\n\n\t\t\t\tconst nodeElement = NodeElements[ prop ];\n\n\t\t\t\treturn ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node[ prop ];\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj ) {\n\n\tconst type = typeof obj;\n\n\tif ( ( type === 'number' ) || ( type === 'boolean' ) ) {\n\n\t\treturn nodeObject( getAutoTypedConstNode( obj ) );\n\n\t} else if ( type === 'object' ) {\n\n\t\tif ( obj?.isNode === true ) {\n\n\t\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\t\tif ( nodeObject === undefined ) {\n\n\t\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\t\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t\t}\n\n\t\t\treturn nodeObject;\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ] );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ] );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc ) {\n\n\t\tsuper();\n\n\t\tthis._jsFunc = jsFunc;\n\n\t}\n\n\tcall( inputs, builder ) {\n\n\t\tinputs = nodeObjects( inputs );\n\n\t\treturn nodeObject( this._jsFunc( inputs, builder ) );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\treturn outputNode ? outputNode.getNodeType( builder ) : super.getNodeType( builder );\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst stackNode = new StackNode();\n\t\tstackNode.outputNode = this.call( {}, stackNode, builder );\n\n\t\treturn stackNode;\n\n\t}\n\n}\n\nconst ShaderNodeScript = function ( jsFunc ) {\n\n\treturn new ShaderNodeInternal( jsFunc );\n\n};\n\nexport const ShaderNode = new Proxy( ShaderNodeScript, shaderNodeHandler );\n\nexport const nodeObject = ( val ) => /* new */ ShaderNodeObject( val );\nexport const nodeObjects = ( val ) => new ShaderNodeObjects( val );\nexport const nodeArray = ( val ) => new ShaderNodeArray( val );\nexport const nodeProxy = ( ...val ) => new ShaderNodeProxy( ...val );\nexport const nodeImmutable = ( ...val ) => new ShaderNodeImmutable( ...val );\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nexport const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getAutoTypedConstNode = ( value ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value );\n\n\t}\n\n};\n\nexport const ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 ) {\n\n\t\t\treturn nodeObject( new ConstNode( getValueFromType( type ), type ) );\n\n\t\t} else {\n\n\t\t\tif ( type === 'color' && params[ 0 ].isNode !== true ) {\n\n\t\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t\t}\n\n\t\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\t\treturn cacheMap.get( params[ 0 ] );\n\n\t\t\t}\n\n\t\t\tconst nodes = params.map( getAutoTypedConstNode );\n\n\t\t\tif ( nodes.length === 1 ) {\n\n\t\t\t\treturn nodeObject( nodes[ 0 ].nodeType === type ? nodes[ 0 ] : new ConvertNode( nodes[ 0 ], type ) );\n\n\t\t\t}\n\n\t\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport const getConstNodeType = ( value ) => value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null );\n", "// core\n//import ArrayUniformNode from '../core/ArrayUniformNode.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport BypassNode from '../core/BypassNode.js';\nimport CacheNode from '../core/CacheNode.js';\nimport CodeNode from '../core/CodeNode.js';\nimport ContextNode from '../core/ContextNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport FunctionCallNode from '../core/FunctionCallNode.js';\nimport FunctionNode from '../core/FunctionNode.js';\nimport InstanceIndexNode from '../core/InstanceIndexNode.js';\nimport PropertyNode from '../core/PropertyNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport VarNode from '../core/VarNode.js';\nimport VaryingNode from '../core/VaryingNode.js';\n\n// accessors\nimport BitangentNode from '../accessors/BitangentNode.js';\nimport BufferNode from '../accessors/BufferNode.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport MaterialNode from '../accessors/MaterialNode.js';\nimport MaterialReferenceNode from '../accessors/MaterialReferenceNode.js';\nimport ModelViewProjectionNode from '../accessors/ModelViewProjectionNode.js';\nimport NormalNode from '../accessors/NormalNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport Object3DNode from '../accessors/Object3DNode.js';\nimport PointUVNode from '../accessors/PointUVNode.js';\nimport PositionNode from '../accessors/PositionNode.js';\nimport ReferenceNode from '../accessors/ReferenceNode.js';\nimport StorageBufferNode from '../accessors/StorageBufferNode.js';\nimport TangentNode from '../accessors/TangentNode.js';\nimport TextureNode from '../accessors/TextureNode.js';\nimport UserDataNode from '../accessors/UserDataNode.js';\nimport UVNode from '../accessors/UVNode.js';\n\n// display\nimport FrontFacingNode from '../display/FrontFacingNode.js';\n\n// gpgpu\nimport ComputeNode from '../gpgpu/ComputeNode.js';\n\n// math\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport CondNode from '../math/CondNode.js';\n\n// utils\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport MaxMipLevelNode from '../utils/MaxMipLevelNode.js';\n\n// shader node utils\nimport { ShaderNode, nodeObject, nodeObjects, nodeArray, nodeProxy, nodeImmutable, ConvertType, getConstNodeType, cacheMaps } from './ShaderNode.js';\n\n// shader node base\n\nexport { ShaderNode, nodeObject, nodeObjects, nodeArray, nodeProxy, nodeImmutable };\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', cacheMaps.float );\nexport const int = new ConvertType( 'int', cacheMaps.int );\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat3 = new ConvertType( 'mat3' );\nexport const imat3 = new ConvertType( 'imat3' );\nexport const umat3 = new ConvertType( 'umat3' );\nexport const bmat3 = new ConvertType( 'bmat3' );\n\nexport const mat4 = new ConvertType( 'mat4' );\nexport const imat4 = new ConvertType( 'imat4' );\nexport const umat4 = new ConvertType( 'umat4' );\nexport const bmat4 = new ConvertType( 'bmat4' );\n\n// core\n\n// @TODO: ArrayUniformNode\n\nexport const func = ( code, includes ) => {\n\n\tconst node = nodeObject( new FunctionNode( code, includes ) );\n\n\tconst call = node.call.bind( node );\n\tnode.call = ( ...params ) => nodeObject( call( params.length > 1 || params[ 0 ]?.isNode === true ? nodeArray( params ) : nodeObjects( params[ 0 ] ) ) );\n\n\treturn node;\n\n};\n\nexport const uniform = ( nodeOrType ) => {\n\n\tconst nodeType = getConstNodeType( nodeOrType );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = nodeOrType.isNode === true ? nodeOrType.node?.value || nodeOrType.value : nodeOrType;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\nexport const fn = ( code, includes ) => func( code, includes ).call;\n\nexport const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\nexport const property = ( name, nodeOrType ) => nodeObject( new PropertyNode( name, getConstNodeType( nodeOrType ) ) );\n\nexport const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nexport const maxMipLevel = nodeProxy( MaxMipLevelNode );\n\nexport const bypass = nodeProxy( BypassNode );\nexport const cache = nodeProxy( CacheNode );\nexport const code = nodeProxy( CodeNode );\nexport const context = nodeProxy( ContextNode );\nexport const expression = nodeProxy( ExpressionNode );\nexport const call = nodeProxy( FunctionCallNode );\nexport const instanceIndex = nodeImmutable( InstanceIndexNode );\nexport const label = nodeProxy( VarNode );\nexport const temp = label;\nexport const varying = nodeProxy( VaryingNode );\n\n// math\n\nexport const EPSILON = float( 1e-6 );\nexport const INFINITY = float( 1e6 );\n\nexport const cond = nodeProxy( CondNode );\n\nexport const add = nodeProxy( OperatorNode, '+' );\nexport const sub = nodeProxy( OperatorNode, '-' );\nexport const mul = nodeProxy( OperatorNode, '*' );\nexport const div = nodeProxy( OperatorNode, '/' );\nexport const remainder = nodeProxy( OperatorNode, '%' );\nexport const equal = nodeProxy( OperatorNode, '==' );\nexport const assign = nodeProxy( OperatorNode, '=' );\nexport const lessThan = nodeProxy( OperatorNode, '<' );\nexport const greaterThan = nodeProxy( OperatorNode, '>' );\nexport const lessThanEqual = nodeProxy( OperatorNode, '<=' );\nexport const greaterThanEqual = nodeProxy( OperatorNode, '>=' );\nexport const and = nodeProxy( OperatorNode, '&&' );\nexport const or = nodeProxy( OperatorNode, '||' );\nexport const xor = nodeProxy( OperatorNode, '^^' );\nexport const bitAnd = nodeProxy( OperatorNode, '&' );\nexport const bitOr = nodeProxy( OperatorNode, '|' );\nexport const bitXor = nodeProxy( OperatorNode, '^' );\nexport const shiftLeft = nodeProxy( OperatorNode, '<<' );\nexport const shiftRight = nodeProxy( OperatorNode, '>>' );\n\nexport const radians = nodeProxy( MathNode, MathNode.RADIANS );\nexport const degrees = nodeProxy( MathNode, MathNode.DEGREES );\nexport const exp = nodeProxy( MathNode, MathNode.EXP );\nexport const exp2 = nodeProxy( MathNode, MathNode.EXP2 );\nexport const log = nodeProxy( MathNode, MathNode.LOG );\nexport const log2 = nodeProxy( MathNode, MathNode.LOG2 );\nexport const sqrt = nodeProxy( MathNode, MathNode.SQRT );\nexport const inversesqrt = nodeProxy( MathNode, MathNode.INVERSE_SQRT );\nexport const floor = nodeProxy( MathNode, MathNode.FLOOR );\nexport const ceil = nodeProxy( MathNode, MathNode.CEIL );\nexport const normalize = nodeProxy( MathNode, MathNode.NORMALIZE );\nexport const fract = nodeProxy( MathNode, MathNode.FRACT );\nexport const sin = nodeProxy( MathNode, MathNode.SIN );\nexport const cos = nodeProxy( MathNode, MathNode.COS );\nexport const tan = nodeProxy( MathNode, MathNode.TAN );\nexport const asin = nodeProxy( MathNode, MathNode.ASIN );\nexport const acos = nodeProxy( MathNode, MathNode.ACOS );\nexport const atan = nodeProxy( MathNode, MathNode.ATAN );\nexport const abs = nodeProxy( MathNode, MathNode.ABS );\nexport const sign = nodeProxy( MathNode, MathNode.SIGN );\nexport const length = nodeProxy( MathNode, MathNode.LENGTH );\nexport const negate = nodeProxy( MathNode, MathNode.NEGATE );\nexport const invert = nodeProxy( MathNode, MathNode.INVERT );\nexport const dFdx = nodeProxy( MathNode, MathNode.DFDX );\nexport const dFdy = nodeProxy( MathNode, MathNode.DFDY );\nexport const round = nodeProxy( MathNode, MathNode.ROUND );\nexport const reciprocal = nodeProxy( MathNode, MathNode.RECIPROCAL );\n\nexport const atan2 = nodeProxy( MathNode, MathNode.ATAN2 );\nexport const min = nodeProxy( MathNode, MathNode.MIN );\nexport const max = nodeProxy( MathNode, MathNode.MAX );\nexport const mod = nodeProxy( MathNode, MathNode.MOD );\nexport const step = nodeProxy( MathNode, MathNode.STEP );\nexport const reflect = nodeProxy( MathNode, MathNode.REFLECT );\nexport const distance = nodeProxy( MathNode, MathNode.DISTANCE );\nexport const dot = nodeProxy( MathNode, MathNode.DOT );\nexport const cross = nodeProxy( MathNode, MathNode.CROSS );\nexport const pow = nodeProxy( MathNode, MathNode.POW );\nexport const pow2 = nodeProxy( MathNode, MathNode.POW, 2 );\nexport const pow3 = nodeProxy( MathNode, MathNode.POW, 3 );\nexport const pow4 = nodeProxy( MathNode, MathNode.POW, 4 );\nexport const transformDirection = nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\n\nexport const mix = nodeProxy( MathNode, MathNode.MIX );\nexport const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\nexport const refract = nodeProxy( MathNode, MathNode.REFRACT );\nexport const smoothstep = nodeProxy( MathNode, MathNode.SMOOTHSTEP );\nexport const faceforward = nodeProxy( MathNode, MathNode.FACEFORWARD );\n\n// accessors\n\nexport const buffer = ( value, nodeOrType, count ) => nodeObject( new BufferNode( value, getConstNodeType( nodeOrType ), count ) );\nexport const storage = ( value, nodeOrType, count ) => nodeObject( new StorageBufferNode( value, getConstNodeType( nodeOrType ), count ) );\n\nexport const cameraProjectionMatrix = nodeImmutable( CameraNode, CameraNode.PROJECTION_MATRIX );\nexport const cameraViewMatrix = nodeImmutable( CameraNode, CameraNode.VIEW_MATRIX );\nexport const cameraNormalMatrix = nodeImmutable( CameraNode, CameraNode.NORMAL_MATRIX );\nexport const cameraWorldMatrix = nodeImmutable( CameraNode, CameraNode.WORLD_MATRIX );\nexport const cameraPosition = nodeImmutable( CameraNode, CameraNode.POSITION );\n\nexport const materialAlphaTest = nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\nexport const materialColor = nodeImmutable( MaterialNode, MaterialNode.COLOR );\nexport const materialEmissive = nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\nexport const materialOpacity = nodeImmutable( MaterialNode, MaterialNode.OPACITY );\n//export const materialSpecular = nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\nexport const materialRoughness = nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\nexport const materialMetalness = nodeImmutable( MaterialNode, MaterialNode.METALNESS );\nexport const materialRotation = nodeImmutable( MaterialNode, MaterialNode.ROTATION );\n\nexport const diffuseColor = nodeImmutable( PropertyNode, 'DiffuseColor', 'vec4' );\nexport const roughness = nodeImmutable( PropertyNode, 'Roughness', 'float' );\nexport const metalness = nodeImmutable( PropertyNode, 'Metalness', 'float' );\nexport const alphaTest = nodeImmutable( PropertyNode, 'AlphaTest', 'float' );\nexport const specularColor = nodeImmutable( PropertyNode, 'SpecularColor', 'color' );\n\nexport const reference = ( name, nodeOrType, object ) => nodeObject( new ReferenceNode( name, getConstNodeType( nodeOrType ), object ) );\nexport const materialReference = ( name, nodeOrType, material ) => nodeObject( new MaterialReferenceNode( name, getConstNodeType( nodeOrType ), material ) );\nexport const userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\n\nexport const modelViewProjection = nodeProxy( ModelViewProjectionNode );\n\nexport const normalGeometry = nodeImmutable( NormalNode, NormalNode.GEOMETRY );\nexport const normalLocal = nodeImmutable( NormalNode, NormalNode.LOCAL );\nexport const normalView = nodeImmutable( NormalNode, NormalNode.VIEW );\nexport const normalWorld = nodeImmutable( NormalNode, NormalNode.WORLD );\nexport const transformedNormalView = nodeImmutable( VarNode, normalView, 'TransformedNormalView' );\nexport const transformedNormalWorld = normalize( transformDirection( transformedNormalView, cameraViewMatrix ) );\n\nexport const tangentGeometry = nodeImmutable( TangentNode, TangentNode.GEOMETRY );\nexport const tangentLocal = nodeImmutable( TangentNode, TangentNode.LOCAL );\nexport const tangentView = nodeImmutable( TangentNode, TangentNode.VIEW );\nexport const tangentWorld = nodeImmutable( TangentNode, TangentNode.WORLD );\nexport const transformedTangentView = nodeImmutable( VarNode, tangentView, 'TransformedTangentView' );\nexport const transformedTangentWorld = normalize( transformDirection( transformedTangentView, cameraViewMatrix ) );\n\nexport const bitangentGeometry = nodeImmutable( BitangentNode, BitangentNode.GEOMETRY );\nexport const bitangentLocal = nodeImmutable( BitangentNode, BitangentNode.LOCAL );\nexport const bitangentView = nodeImmutable( BitangentNode, BitangentNode.VIEW );\nexport const bitangentWorld = nodeImmutable( BitangentNode, BitangentNode.WORLD );\nexport const transformedBitangentView = normalize( mul( cross( transformedNormalView, transformedTangentView ), tangentGeometry.w ) );\nexport const transformedBitangentWorld = normalize( transformDirection( transformedBitangentView, cameraViewMatrix ) );\n\nexport const modelViewMatrix = nodeImmutable( ModelNode, ModelNode.VIEW_MATRIX );\nexport const modelNormalMatrix = nodeImmutable( ModelNode, ModelNode.NORMAL_MATRIX );\nexport const modelWorldMatrix = nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\nexport const modelPosition = nodeImmutable( ModelNode, ModelNode.POSITION );\nexport const modelViewPosition = nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\n\nexport const objectViewMatrix = nodeProxy( Object3DNode, Object3DNode.VIEW_MATRIX );\nexport const objectNormalMatrix = nodeProxy( Object3DNode, Object3DNode.NORMAL_MATRIX );\nexport const objectWorldMatrix = nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );\nexport const objectPosition = nodeProxy( Object3DNode, Object3DNode.POSITION );\nexport const objectViewPosition = nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );\n\nexport const positionGeometry = nodeImmutable( PositionNode, PositionNode.GEOMETRY );\nexport const positionLocal = nodeImmutable( PositionNode, PositionNode.LOCAL );\nexport const positionWorld = nodeImmutable( PositionNode, PositionNode.WORLD );\nexport const positionWorldDirection = nodeImmutable( PositionNode, PositionNode.WORLD_DIRECTION );\nexport const positionView = nodeImmutable( PositionNode, PositionNode.VIEW );\nexport const positionViewDirection = nodeImmutable( PositionNode, PositionNode.VIEW_DIRECTION );\n\nexport const texture = nodeProxy( TextureNode );\nexport const sampler = ( texture ) => nodeObject( new ConvertNode( texture.isNode === true ? texture : new TextureNode( texture ), 'sampler' ) );\nexport const uv = ( ...params ) => nodeObject( new UVNode( ...params ) );\nexport const pointUV = nodeImmutable( PointUVNode );\n\n// gpgpu\n\nexport const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\n// display\n\nexport const frontFacing = nodeImmutable( FrontFacingNode );\nexport const faceDirection = sub( mul( float( frontFacing ), 2 ), 1 );\n\n// lighting\n\n\n// utils\n\nexport const element = nodeProxy( ArrayElementNode );\n\n// miscellaneous\n\nexport const lumaCoeffs = vec3( 0.2125, 0.7154, 0.0721 );\n\nexport const luminance = ( color, luma = lumaCoeffs ) => dot( color, luma );\nexport const difference = ( a, b ) => abs( sub( a, b ) );\nexport const dotNV = clamp( dot( transformedNormalView, positionViewDirection ) );\nexport const TBNViewMatrix = mat3( tangentView, bitangentView, normalView );\n", "import Node from '../core/Node.js';\nimport {\n\ttransformedNormalView, positionViewDirection,\n\ttransformDirection, negate, reflect, cameraViewMatrix\n} from '../shadernode/ShaderNodeBaseElements.js';\n\nclass ReflectVectorNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn 'reflectVector';\n\n\t}\n\n\tconstruct() {\n\n\t\tconst reflectView = reflect( negate( positionViewDirection ), transformedNormalView );\n\n\t\treturn transformDirection( reflectView, cameraViewMatrix );\n\n\t}\n\n}\n\nexport default ReflectVectorNode;\n", "import TextureNode from './TextureNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport ReflectVectorNode from './ReflectVectorNode.js';\n\nimport { negate, vec3, nodeObject } from '../shadernode/ShaderNodeBaseElements.js';\n\nlet defaultUV;\n\nclass CubeTextureNode extends TextureNode {\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\tdefaultUV ||= new ReflectVectorNode();\n\n\t\treturn defaultUV;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { uvNode, levelNode } = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isCubeTexture !== true ) {\n\n\t\t\tthrow new Error( 'CubeTextureNode: Need a three.js cube texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = UniformNode.prototype.generate.call( this, builder, 'cubeTexture' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst uvNodeObject = nodeObject( uvNode );\n\t\t\t\tconst cubeUV = vec3( negate( uvNodeObject.x ), uvNodeObject.yz );\n\t\t\t\tconst uvSnippet = cubeUV.build( builder, 'vec3' );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, 'vec4' );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tlet snippet = null;\n\n\t\t\t\tif ( levelNode?.isNode === true) {\n\n\t\t\t\t\tconst levelSnippet = levelNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getCubeTextureLevel( textureProperty, uvSnippet, levelSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getCubeTexture( textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\treturn builder.format( propertyName, 'vec4', output );\n\n\t\t}\n\n\t}\n\n}\n\nexport default CubeTextureNode;\n", "import Node from '../core/Node.js';\nimport {\n\tvec3,\n\tmat3,\n\tmul,\n\tassign,\n\tbuffer,\n\telement,\n\tdot,\n\tdiv,\n\ttemp,\n\tinstanceIndex,\n\tpositionLocal,\n\tnormalLocal\n} from '../shadernode/ShaderNodeBaseElements.js';\n\nclass InstanceNode extends Node {\n\n\tconstructor( instanceMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.instanceMesh = instanceMesh;\n\n\t\t//\n\n\t\tconst instanceBufferNode = buffer( instanceMesh.instanceMatrix.array, 'mat4', instanceMesh.count );\n\n\t\tthis.instanceMatrixNode = temp( element( instanceBufferNode, instanceIndex ) ); // @TODO: a possible caching issue here?\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { instanceMatrixNode } = this;\n\n\t\t// POSITION\n\n\t\tconst instancePosition = mul( instanceMatrixNode, positionLocal ).xyz;\n\n\t\t// NORMAL\n\n\t\tconst m = mat3( instanceMatrixNode[ 0 ].xyz, instanceMatrixNode[ 1 ].xyz, instanceMatrixNode[ 2 ].xyz );\n\n\t\tconst transformedNormal = div( normalLocal, vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) ) );\n\n\t\tconst instanceNormal = mul( m, transformedNormal ).xyz;\n\n\t\t// ASSIGNS\n\n\t\tassign( positionLocal, instancePosition ).build( builder );\n\t\tassign( normalLocal, instanceNormal ).build( builder );\n\n\t}\n\n}\n\nexport default InstanceNode;\n", "import Node from '../core/Node.js';\nimport {\n\tShaderNode,\n\tattribute,\n\tbuffer,\n\tmat4,\n\tuniform,\n\tpositionLocal,\n\tnormalLocal,\n\ttangentLocal,\n\tassign,\n\telement,\n\tadd,\n\tmul,\n\ttransformDirection\n} from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { NodeUpdateType } from '../core/constants.js';\n\nconst Skinning = new ShaderNode( ( inputs, builder ) => {\n\n\tconst { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;\n\n\tconst boneMatX = element( boneMatrices, index.x );\n\tconst boneMatY = element( boneMatrices, index.y );\n\tconst boneMatZ = element( boneMatrices, index.z );\n\tconst boneMatW = element( boneMatrices, index.w );\n\n\t// POSITION\n\n\tconst skinVertex = mul( bindMatrix, positionLocal );\n\n\tconst skinned = add(\n\t\tmul( mul( boneMatX, skinVertex ), weight.x ),\n\t\tmul( mul( boneMatY, skinVertex ), weight.y ),\n\t\tmul( mul( boneMatZ, skinVertex ), weight.z ),\n\t\tmul( mul( boneMatW, skinVertex ), weight.w )\n\t);\n\n\tconst skinPosition = mul( bindMatrixInverse, skinned ).xyz;\n\n\t// NORMAL\n\n\tlet skinMatrix = add(\n\t\tmul( weight.x, boneMatX ),\n\t\tmul( weight.y, boneMatY ),\n\t\tmul( weight.z, boneMatZ ),\n\t\tmul( weight.w, boneMatW )\n\t);\n\n\tskinMatrix = mul( mul( bindMatrixInverse, skinMatrix ), bindMatrix );\n\n\tconst skinNormal = transformDirection( skinMatrix, normalLocal ).xyz;\n\n\t// ASSIGNS\n\n\tassign( positionLocal, skinPosition ).build( builder );\n\tassign( normalLocal, skinNormal ).build( builder );\n\n\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\tassign( tangentLocal, skinNormal ).build( builder );\n\n\t}\n\n} );\n\nclass SkinningNode extends Node {\n\n\tconstructor( skinnedMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.skinnedMesh = skinnedMesh;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\tthis.bindMatrixNode = uniform( mat4( skinnedMesh.bindMatrix ) );\n\t\tthis.bindMatrixInverseNode = uniform( mat4( skinnedMesh.bindMatrixInverse ) );\n\t\tthis.boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tSkinning.call( {\n\t\t\tindex: this.skinIndexNode,\n\t\t\tweight: this.skinWeightNode,\n\t\t\tbindMatrix: this.bindMatrixNode,\n\t\t\tbindMatrixInverse: this.bindMatrixInverseNode,\n\t\t\tboneMatrices: this.boneMatricesNode\n\t\t}, builder );\n\n\t}\n\n\tupdate() {\n\n\t\tthis.skinnedMesh.skeleton.update();\n\n\t}\n\n}\n\nexport default SkinningNode;\n", "import TempNode from '../core/Node.js';\nimport { ShaderNode, EPSILON, vec3, sub, mul, div, cond, lessThan, equal, max } from '../shadernode/ShaderNodeBaseElements.js';\n\nexport const BurnNode = new ShaderNode( ( { base, blend } ) => {\n\n\tconst fn = ( c ) => cond( lessThan( blend[ c ], EPSILON ), blend[ c ], max( sub( 1.0, div( sub( 1.0, base[ c ] ), blend[ c ] ) ), 0 ) );\n\n\treturn vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );\n\n} );\n\nexport const DodgeNode = new ShaderNode( ( { base, blend } ) => {\n\n\tconst fn = ( c ) => cond( equal( blend[ c ], 1.0 ), blend[ c ], max( div( base[ c ], sub( 1.0, blend[ c ] ) ), 0 ) );\n\n\treturn vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );\n\n} );\n\nexport const ScreenNode = new ShaderNode( ( { base, blend } ) => {\n\n\tconst fn = ( c ) => sub( 1.0, mul( sub( 1.0, base[ c ] ), sub( 1.0, blend[ c ] ) ) );\n\n\treturn vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );\n\n} );\n\nexport const OverlayNode = new ShaderNode( ( { base, blend } ) => {\n\n\tconst fn = ( c ) => cond( lessThan( base[ c ], 0.5 ), mul( 2.0, base[ c ], blend[ c ] ), sub( 1.0, mul( sub( 1.0, base[ c ] ), sub( 1.0, blend[ c ] ) ) ) );\n\n\treturn vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );\n\n} );\n\nclass BlendModeNode extends TempNode {\n\n\tstatic BURN = 'burn';\n\tstatic DODGE = 'dodge';\n\tstatic SCREEN = 'screen';\n\tstatic OVERLAY = 'overlay';\n\n\tconstructor( blendMode, baseNode, blendNode ) {\n\n\t\tsuper();\n\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.baseNode = baseNode;\n\t\tthis.blendNode = blendNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { blendMode, baseNode, blendNode } = this;\n\t\tconst params = { base: baseNode, blend: blendNode };\n\n\t\tlet outputNode = null;\n\n\t\tif ( blendMode === BlendModeNode.BURN ) {\n\n\t\t\toutputNode = BurnNode.call( params );\n\n\t\t} else if ( blendMode === BlendModeNode.DODGE ) {\n\n\t\t\toutputNode = DodgeNode.call( params );\n\n\t\t} else if ( blendMode === BlendModeNode.SCREEN ) {\n\n\t\t\toutputNode = ScreenNode.call( params );\n\n\t\t} else if ( blendMode === BlendModeNode.OVERLAY ) {\n\n\t\t\toutputNode = OverlayNode.call( params );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default BlendModeNode;\n", "import TempNode from '../core/TempNode.js';\nimport { ShaderNode, vec3, mat3, add, sub, mul, max, div, float, mix, cos, sin, atan2, sqrt, luminance } from '../shadernode/ShaderNodeBaseElements.js';\n\nconst saturationNode = new ShaderNode( ( { color, adjustment } ) => {\n\n\treturn mix( luminance( color ), color, adjustment );\n\n} );\n\nconst vibranceNode = new ShaderNode( ( { color, adjustment } ) => {\n\n\tconst average = div( add( color.r, color.g, color.b ), 3.0 );\n\n\tconst mx = max( color.r, max( color.g, color.b ) );\n\tconst amt = mul( sub( mx, average ), mul( - 3.0, adjustment ) );\n\n\treturn mix( color.rgb, vec3( mx ), amt );\n\n} );\n\nconst hueNode = new ShaderNode( ( { color, adjustment } ) => {\n\n\tconst RGBtoYIQ = mat3( 0.299, 0.587, 0.114, 0.595716, - 0.274453, - 0.321263, 0.211456, - 0.522591, 0.311135 );\n\tconst YIQtoRGB = mat3( 1.0, 0.9563, 0.6210, 1.0, - 0.2721, - 0.6474, 1.0, - 1.107, 1.7046 );\n\n\tconst yiq = mul( RGBtoYIQ, color );\n\n\tconst hue = add( atan2( yiq.z, yiq.y ), adjustment );\n\tconst chroma = sqrt( add( mul( yiq.z, yiq.z ), mul( yiq.y, yiq.y ) ) );\n\n\treturn mul( YIQtoRGB, vec3( yiq.x, mul( chroma, cos( hue ) ), mul( chroma, sin( hue ) ) ) );\n\n} );\n\nclass ColorAdjustmentNode extends TempNode {\n\n\tstatic SATURATION = 'saturation';\n\tstatic VIBRANCE = 'vibrance';\n\tstatic HUE = 'hue';\n\n\tconstructor( method, colorNode, adjustmentNode = float( 1 ) ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.method = method;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.adjustmentNode = adjustmentNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { method, colorNode, adjustmentNode } = this;\n\n\t\tconst callParams = { color: colorNode, adjustment: adjustmentNode };\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === ColorAdjustmentNode.SATURATION ) {\n\n\t\t\toutputNode = saturationNode.call( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.VIBRANCE ) {\n\n\t\t\toutputNode = vibranceNode.call( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.HUE ) {\n\n\t\t\toutputNode = hueNode.call( callParams );\n\n\t\t} else {\n\n\t\t\tconsole.error( `${ this.type }: Method \"${ this.method }\" not supported!` );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ColorAdjustmentNode;\n", "import TempNode from '../core/Node.js';\nimport { ShaderNode, vec3, pow, mul, sub, mix, vec4, lessThanEqual } from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { LinearEncoding, sRGBEncoding } from 'three';\n\nexport const LinearToLinear = new ShaderNode( ( inputs ) => {\n\n\treturn inputs.value;\n\n} );\n\nexport const LinearTosRGB = new ShaderNode( ( inputs ) => {\n\n\tconst { value } = inputs;\n\n\tconst rgb = value.rgb;\n\n\tconst a = sub( mul( pow( value.rgb, vec3( 0.41666 ) ), 1.055 ), vec3( 0.055 ) );\n\tconst b = mul( rgb, 12.92 );\n\tconst factor = vec3( lessThanEqual( rgb, vec3( 0.0031308 ) ) );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn vec4( rgbResult, value.a );\n\n} );\n\nconst EncodingLib = {\n\tLinearToLinear,\n\tLinearTosRGB\n};\n\nclass ColorSpaceNode extends TempNode {\n\n\tstatic LINEAR_TO_LINEAR = 'LinearToLinear';\n\tstatic LINEAR_TO_SRGB = 'LinearTosRGB';\n\n\tconstructor( method, node ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.method = method;\n\n\t\tthis.node = node;\n\n\t}\n\n\tfromEncoding( encoding ) {\n\n\t\tlet method = null;\n\n\t\tif ( encoding === LinearEncoding ) {\n\n\t\t\tmethod = 'Linear';\n\n\t\t} else if ( encoding === sRGBEncoding ) {\n\n\t\t\tmethod = 'sRGB';\n\n\t\t}\n\n\t\tthis.method = 'LinearTo' + method;\n\n\t\treturn this;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst method = this.method;\n\t\tconst node = this.node;\n\n\t\tlet outputNode = null;\n\n\t\tif ( method !== ColorSpaceNode.LINEAR_TO_LINEAR ) {\n\n\t\t\tconst encodingFunctionNode = EncodingLib[ method ];\n\n\t\t\toutputNode = encodingFunctionNode.call( {\n\t\t\t\tvalue: node\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\toutputNode = node;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ColorSpaceNode;\n", "import TempNode from '../core/TempNode.js';\nimport { ShaderNode, positionView, normalView, uv, vec3, add, sub, mul, dFdx, dFdy, cross, max, dot, normalize, inversesqrt, faceDirection, modelNormalMatrix, TBNViewMatrix } from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { TangentSpaceNormalMap, ObjectSpaceNormalMap } from 'three';\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2ArbNode = new ShaderNode( ( inputs ) => {\n\n\tconst { eye_pos, surf_norm, mapN, uv } = inputs;\n\n\tconst q0 = dFdx( eye_pos.xyz );\n\tconst q1 = dFdy( eye_pos.xyz );\n\tconst st0 = dFdx( uv.st );\n\tconst st1 = dFdy( uv.st );\n\n\tconst N = surf_norm; // normalized\n\n\tconst q1perp = cross( q1, N );\n\tconst q0perp = cross( N, q0 );\n\n\tconst T = add( mul( q1perp, st0.x ), mul( q0perp, st1.x ) );\n\tconst B = add( mul( q1perp, st0.y ), mul( q0perp, st1.y ) );\n\n\tconst det = max( dot( T, T ), dot( B, B ) );\n\tconst scale = mul( faceDirection, inversesqrt( det ) );\n\n\treturn normalize( add( mul( T, mul( mapN.x, scale ) ), mul( B, mul( mapN.y, scale ) ), mul( N, mapN.z ) ) );\n\n} );\n\nclass NormalMapNode extends TempNode {\n\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.node = node;\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tconst normalOP = mul( this.node, 2.0 );\n\t\tlet normalMap = sub( normalOP, 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tconst normalMapScale = mul( normalMap.xy, scaleNode );\n\t\t\tnormalMap = vec3( normalMapScale, normalMap.z );\n\n\t\t}\n\n\t\tlet outputNode = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutputNode = normalize( mul( modelNormalMatrix, normalMap ) );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\tconst tangent = builder.hasGeometryAttribute( 'tangent' );\n\n\t\t\tif ( tangent === true ) {\n\n\t\t\t\toutputNode = normalize( mul( TBNViewMatrix, normalMap ) );\n\n\t\t\t} else {\n\n\t\t\t\toutputNode = perturbNormal2ArbNode.call( {\n\t\t\t\t\teye_pos: positionView,\n\t\t\t\t\tsurf_norm: normalView,\n\t\t\t\t\tmapN: normalMap,\n\t\t\t\t\tuv: uv()\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default NormalMapNode;\n", "import TempNode from '../core/Node.js';\nimport { mul, floor, reciprocal } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass PosterizeNode extends TempNode {\n\n\tconstructor( sourceNode, stepsNode ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.stepsNode = stepsNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { sourceNode, stepsNode } = this;\n\n\t\treturn mul( floor( mul( sourceNode, stepsNode ) ), reciprocal( stepsNode ) );\n\n\t}\n\n}\n\nexport default PosterizeNode;\n", "import TempNode from '../core/Node.js';\nimport { ShaderNode, mul, float } from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { LinearToneMapping } from 'three';\n\n// exposure only\nexport const LinearToneMappingNode = new ShaderNode( ( { color, exposure } ) => {\n\n\treturn mul( color, exposure );\n\n} );\n\nclass ToneMappingNode extends TempNode {\n\n\tconstructor( toneMapping, exposureNode = float( 1 ), colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.toneMapping = toneMapping;\n\n\t\tthis.exposureNode = exposureNode;\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\n\t\tconst toneMapping = this.toneMapping;\n\t\tconst toneMappingParams = { exposure: this.exposureNode, color: colorNode };\n\n\t\tlet outputNode = null;\n\n\t\tif ( toneMapping === LinearToneMapping ) {\n\n\t\t\toutputNode = LinearToneMappingNode.call( toneMappingParams );\n\n\t\t} else {\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ToneMappingNode;\n", "import Node from '../core/Node.js';\nimport { uniform, div, vec2, invert } from '../shadernode/ShaderNodeBaseElements.js';\nimport { Vector2 } from 'three';\nimport { NodeUpdateType } from '../core/constants.js';\n\nlet resolution;\n\nclass ViewportNode extends Node {\n\n\tstatic COORDINATE = 'coordinate';\n\tstatic RESOLUTION = 'resolution';\n\tstatic TOP_LEFT = 'topLeft';\n\tstatic BOTTOM_LEFT = 'bottomLeft';\n\tstatic TOP_RIGHT = 'topRight';\n\tstatic BOTTOM_RIGHT = 'bottomRight';\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.scope === ViewportNode.COORDINATE ? 'vec4' : 'vec2';\n\n\t}\n\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ViewportNode.RESOLUTION ) {\n\n\t\t\tupdateType = NodeUpdateType.FRAME;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\tupdate( { renderer } ) {\n\n\t\trenderer.getSize( resolution );\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === ViewportNode.COORDINATE ) return;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ViewportNode.RESOLUTION ) {\n\n\t\t\tresolution ||= new Vector2();\n\n\t\t\toutput = uniform( resolution );\n\n\t\t} else {\n\n\t\t\tconst coordinateNode = vec2( new ViewportNode( ViewportNode.COORDINATE ) );\n\t\t\tconst resolutionNode = new ViewportNode( ViewportNode.RESOLUTION );\n\n\t\t\toutput = div( coordinateNode, resolutionNode );\n\n\t\t\tlet outX = output.x;\n\t\t\tlet outY = output.y;\n\n\t\t\tif ( /top/i.test( scope ) && builder.isFlipY() ) outY = invert( outY );\n\t\t\telse if ( /bottom/i.test( scope ) && builder.isFlipY() === false ) outY = invert( outY );\n\n\t\t\tif ( /right/i.test( scope ) ) outX = invert( outX );\n\n\t\t\toutput = vec2( outX, outY );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ViewportNode.COORDINATE ) {\n\n\t\t\treturn builder.getFragCoord();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nexport default ViewportNode;\n", "import Node from '../core/Node.js';\n\nclass LightingNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nexport default LightingNode;\n", "import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../shadernode/ShaderNodeElements.js';\n\nimport { Color } from 'three';\n\nclass AnalyticLightNode extends LightingNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis.light = light;\n\n\t\tthis.colorNode = uniform( new Color() );\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.colorNode.value.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nexport default AnalyticLightNode;\n", "import Node from '../core/Node.js';\nimport AnalyticLightNode from './AnalyticLightNode.js';\n\nconst references = new WeakMap();\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nclass LightsNode extends Node {\n\n\tconstructor( lightNodes = [] ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.lightNodes = lightNodes;\n\n\t\tthis._hash = null;\n\n\t}\n\n\tget hasLight() {\n\n\t\treturn this.lightNodes.length > 0;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst lightNodes = this.lightNodes;\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this._hash === null ) {\n\n\t\t\tlet hash = '';\n\n\t\t\tconst lightNodes = this.lightNodes;\n\n\t\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\t\thash += lightNode.getHash( builder ) + ' ';\n\n\t\t\t}\n\n\t\t\tthis._hash = hash;\n\n\t\t}\n\n\t\treturn this._hash;\n\n\t}\n\n\tgetLightNodeByHash( hash ) {\n\n\t\tconst lightNodes = this.lightNodes;\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tif ( lightNode.light.uuid === hash ) {\n\n\t\t\t\treturn lightNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfromLights( lights ) {\n\n\t\tconst lightNodes = [];\n\n\t\tlights = sortLights( lights );\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tlet lightNode = this.getLightNodeByHash( light.uuid );\n\n\t\t\tif ( lightNode === null ) {\n\n\t\t\t\tconst lightClass = light.constructor;\n\t\t\t\tconst lightNodeClass = references.has( lightClass ) ? references.get( lightClass ) : AnalyticLightNode;\n\n\t\t\t\tlightNode = new lightNodeClass( light );\n\n\t\t\t}\n\n\t\t\tlightNodes.push( lightNode );\n\n\t\t}\n\n\t\tthis.lightNodes = lightNodes;\n\t\tthis._hash = null;\n\n\t\treturn this;\n\n\t}\n\n\tstatic setReference( lightClass, lightNodeClass ) {\n\n\t\treferences.set( lightClass, lightNodeClass );\n\n\t}\n\n}\n\nexport default LightsNode;\n", "import ContextNode from '../core/ContextNode.js';\nimport { float, vec3, add, temp } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass LightingContextNode extends ContextNode {\n\n\tconstructor( node, lightingModelNode = null ) {\n\n\t\tsuper( node );\n\n\t\tthis.lightingModelNode = lightingModelNode;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn 'vec3';\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst { lightingModelNode } = this;\n\n\t\tconst context = this.context = {}; // reset context\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst directDiffuse = temp( vec3() ),\n\t\t\tdirectSpecular = temp( vec3() ),\n\t\t\tindirectDiffuse = temp( vec3() ),\n\t\t\tindirectSpecular = temp( vec3() ),\n\t\t\ttotal = add( directDiffuse, directSpecular, indirectDiffuse, indirectSpecular );\n\n\t\tconst reflectedLight = {\n\t\t\tdirectDiffuse,\n\t\t\tdirectSpecular,\n\t\t\tindirectDiffuse,\n\t\t\tindirectSpecular,\n\t\t\ttotal\n\t\t};\n\n\t\tconst lighting = {\n\t\t\tradiance: temp( vec3() ),\n\t\t\tirradiance: temp( vec3() ),\n\t\t\tiblIrradiance: temp( vec3() ),\n\t\t\tambientOcclusion: temp( float( 1 ) )\n\t\t};\n\n\t\tObject.assign( properties, reflectedLight, lighting );\n\t\tObject.assign( context, lighting );\n\n\t\tcontext.reflectedLight = reflectedLight;\n\t\tcontext.lightingModelNode = lightingModelNode || context.lightingModelNode;\n\n\t\tif ( lightingModelNode?.indirectDiffuse ) lightingModelNode.indirectDiffuse.call( context );\n\t\tif ( lightingModelNode?.indirectSpecular ) lightingModelNode.indirectSpecular.call( context );\n\t\tif ( lightingModelNode?.ambientOcclusion ) lightingModelNode.ambientOcclusion.call( context );\n\n\t\treturn super.construct( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { context } = this;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tsuper.generate( builder, type );\n\n\t\treturn context.reflectedLight.total.build( builder, type );\n\n\t}\n\n}\n\nexport default LightingContextNode;\n", "import TempNode from '../core/TempNode.js';\nimport { nodeObject, vec2, add, mul, atan2, asin, clamp, positionWorldDirection } from '../shadernode/ShaderNodeElements.js';\n\nclass EquirectUVNode extends TempNode {\n\n\tconstructor( dirNode = positionWorldDirection ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.dirNode = dirNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst dir = nodeObject( this.dirNode );\n\n\t\tconst u = add( mul( atan2( dir.z, dir.x ), 1 / ( Math.PI * 2 ) ), 0.5 );\n\t\tconst v = add( mul( asin( clamp( dir.y, - 1.0, 1.0 ) ), 1 / Math.PI ), 0.5 );\n\n\t\treturn vec2( u, v );\n\n\t}\n\n}\n\nexport default EquirectUVNode;\n", "import TempNode from '../core/TempNode.js';\nimport { vec2, vec3, negate, normalize, cross, dot, mul, add, transformedNormalView, positionViewDirection } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass MatcapUVNode extends TempNode {\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tconstruct() {\n\n\t\tconst x = normalize( vec3( positionViewDirection.z, 0, negate( positionViewDirection.x ) ) );\n\t\tconst y = cross( positionViewDirection, x );\n\n\t\treturn add( mul( vec2( dot( x, transformedNormalView ), dot( y, transformedNormalView ) ), 0.495 ), 0.5 );\n\n\t}\n\n}\n\nexport default MatcapUVNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TimerNode extends UniformNode {\n\n\tstatic LOCAL = 'local';\n\tstatic GLOBAL = 'global';\n\tstatic DELTA = 'delta';\n\tstatic FRAME = 'frame';\n\n\tconstructor( scope = TimerNode.LOCAL, scale = 1, value = 0 ) {\n\n\t\tsuper( value );\n\n\t\tthis.scope = scope;\n\t\tthis.scale = scale;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n/*\n\t@TODO:\n\tgetNodeType( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === TimerNode.FRAME ) {\n\n\t\t\treturn 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n*/\n\tupdate( frame ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scale = this.scale;\n\n\t\tif ( scope === TimerNode.LOCAL ) {\n\n\t\t\tthis.value += frame.deltaTime * scale;\n\n\t\t} else if ( scope === TimerNode.DELTA ) {\n\n\t\t\tthis.value = frame.deltaTime * scale;\n\n\t\t} else if ( scope === TimerNode.FRAME ) {\n\n\t\t\tthis.value = frame.frameId;\n\n\t\t} else {\n\n\t\t\t// global\n\n\t\t\tthis.value = frame.time * scale;\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\t\tdata.scale = this.scale;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\t\tthis.scale = data.scale;\n\n\t}\n\n}\n\nexport default TimerNode;\n", "import Node from '../core/Node.js';\nimport TimerNode from './TimerNode.js';\nimport { abs, fract, round, sin, add, sub, mul } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass OscNode extends Node {\n\n\tstatic SINE = 'sine';\n\tstatic SQUARE = 'square';\n\tstatic TRIANGLE = 'triangle';\n\tstatic SAWTOOTH = 'sawtooth';\n\n\tconstructor( method = OscNode.SINE, timeNode = new TimerNode() ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\t\tthis.timeNode = timeNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.timeNode.getNodeType( builder );\n\n\t}\n\n\tconstruct() {\n\n\t\tconst method = this.method;\n\t\tconst timeNode = this.timeNode;\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === OscNode.SINE ) {\n\n\t\t\toutputNode = add( mul( sin( mul( add( timeNode, .75 ), Math.PI * 2 ) ), .5 ), .5 );\n\n\t\t} else if ( method === OscNode.SQUARE ) {\n\n\t\t\toutputNode = round( fract( timeNode ) );\n\n\t\t} else if ( method === OscNode.TRIANGLE ) {\n\n\t\t\toutputNode = abs( sub( 1, mul( fract( add( timeNode, .5 ) ), 2 ) ) );\n\n\t\t} else if ( method === OscNode.SAWTOOTH ) {\n\n\t\t\toutputNode = fract( timeNode );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\nexport default OscNode;\n", "import Node from '../core/Node.js';\nimport { add, sub, div, mul, clamp } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass RemapNode extends Node {\n\n\tconstructor( node, inLowNode, inHighNode, outLowNode, outHighNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.inLowNode = inLowNode;\n\t\tthis.inHighNode = inHighNode;\n\t\tthis.outLowNode = outLowNode;\n\t\tthis.outHighNode = outHighNode;\n\n\t\tthis.doClamp = true;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = div( sub( node, inLowNode ), sub( inHighNode, inLowNode ) );\n\n\t\tif ( doClamp === true ) t = clamp( t );\n\n\t\treturn add( mul( sub( outHighNode, outLowNode ), t ), outLowNode );\n\n\t}\n\n}\n\nexport default RemapNode;\n", "import TempNode from '../core/TempNode.js';\nimport { vec2, add, sub, mul, cos, sin } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass RotateUVNode extends TempNode {\n\n\tconstructor( uvNode, rotationNode, centerNode = vec2( .5 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.rotationNode = rotationNode;\n\t\tthis.centerNode = centerNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { uvNode, rotationNode, centerNode } = this;\n\n\t\tconst cosAngle = cos( rotationNode );\n\t\tconst sinAngle = sin( rotationNode );\n\n\t\treturn vec2(\n\t\t\tadd( add( mul( cosAngle, sub( uvNode.x, centerNode.x ) ), mul( sinAngle, sub( uvNode.y, centerNode.y ) ) ), centerNode.x ),\n\t\t\tadd( sub( mul( cosAngle, sub( uvNode.y, centerNode.y ) ), mul( sinAngle, sub( uvNode.x, centerNode.x ) ) ), centerNode.y )\n\t\t);\n\n\t}\n\n}\n\nexport default RotateUVNode;\n", "import Node from '../core/Node.js';\nimport { add, mul, div, log2, clamp, maxMipLevel } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass SpecularMIPLevelNode extends Node {\n\n\tconstructor( textureNode, roughnessNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.roughnessNode = roughnessNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { textureNode, roughnessNode } = this;\n\n\t\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\n\t\tconst maxMIPLevelScalar = maxMipLevel( textureNode );\n\n\t\tconst sigma = div( mul( Math.PI, mul( roughnessNode, roughnessNode ) ), add( 1.0, roughnessNode ) );\n\t\tconst desiredMIPLevel = add( maxMIPLevelScalar, log2( sigma ) );\n\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n}\n\nexport default SpecularMIPLevelNode;\n", "import Node from '../core/Node.js';\nimport ConstNode from '../core/ConstNode.js';\nimport UVNode from '../accessors/UVNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport JoinNode from '../utils/JoinNode.js';\n\nclass SpriteSheetUVNode extends Node {\n\n\tconstructor( countNode, uvNode = new UVNode(), frameNode = new ConstNode( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.countNode = countNode;\n\t\tthis.uvNode = uvNode;\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { frameNode, uvNode, countNode } = this;\n\n\t\tconst one = new ConstNode( 1 );\n\n\t\tconst width = new SplitNode( countNode, 'x' );\n\t\tconst height = new SplitNode( countNode, 'y' );\n\n\t\tconst total = new OperatorNode( '*', width, height );\n\n\t\tconst roundFrame = new MathNode( MathNode.FLOOR, new MathNode( MathNode.MOD, frameNode, total ) );\n\n\t\tconst frameNum = new OperatorNode( '+', roundFrame, one );\n\n\t\tconst cell = new MathNode( MathNode.MOD, roundFrame, width );\n\t\tconst row = new MathNode( MathNode.CEIL, new OperatorNode( '/', frameNum, width ) );\n\t\tconst rowInv = new OperatorNode( '-', height, row );\n\n\t\tconst scale = new OperatorNode( '/', one, countNode );\n\n\t\tconst uvFrameOffset = new JoinNode( [\n\t\t\tnew OperatorNode( '*', cell, new SplitNode( scale, 'x' ) ),\n\t\t\tnew OperatorNode( '*', rowInv, new SplitNode( scale, 'y' ) )\n\t\t] );\n\n\t\tconst uvScale = new OperatorNode( '*', uvNode, scale );\n\t\tconst uvFrame = new OperatorNode( '+', uvScale, uvFrameOffset );\n\n\t\treturn uvFrame;\n\n\t}\n\n}\n\nexport default SpriteSheetUVNode;\n", "import Node from '../core/Node.js';\nimport { float, vec3, add, mul, div, dot, normalize, abs, texture, positionWorld, normalWorld } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass TriplanarTexturesNode extends Node {\n\n\tconstructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionWorld, normalNode = normalWorld ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.textureXNode = textureXNode;\n\t\tthis.textureYNode = textureYNode;\n\t\tthis.textureZNode = textureZNode;\n\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.positionNode = positionNode;\n\t\tthis.normalNode = normalNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;\n\n\t\t// Ref: https://github.com/keijiro/StandardTriplanar\n\n\t\t// Blending factor of triplanar mapping\n\t\tlet bf = normalize( abs( normalNode ) );\n\t\tbf = div( bf, dot( bf, vec3( 1.0 ) ) );\n\n\t\t// Triplanar mapping\n\t\tconst tx = mul( positionNode.yz, scaleNode );\n\t\tconst ty = mul( positionNode.zx, scaleNode );\n\t\tconst tz = mul( positionNode.xy, scaleNode );\n\n\t\t// Base color\n\t\tconst textureX = textureXNode.value;\n\t\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\t\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\t\tconst cx = mul( texture( textureX, tx ), bf.x );\n\t\tconst cy = mul( texture( textureY, ty ), bf.y );\n\t\tconst cz = mul( texture( textureZ, tz ), bf.z );\n\n\t\treturn add( cx, cy, cz );\n\n\t}\n\n}\n\nexport default TriplanarTexturesNode;\n", "import Node from '../core/Node.js';\nimport { attribute, float } from '../shadernode/ShaderNodeBaseElements.js';\nimport { MathUtils, InstancedBufferAttribute } from 'three';\n\nclass RangeNode extends Node {\n\n\tconstructor( min, max ) {\n\n\t\tsuper();\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tconst min = this.min;\n\n\t\tlet length = 1;\n\n\t\tif ( min.isVector2 ) length = 2;\n\t\telse if ( min.isVector3 ) length = 3;\n\t\telse if ( min.isVector4 ) length = 4;\n\t\telse if ( min.isColor ) length = 3;\n\n\t\treturn length;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn ( builder.object.isInstancedMesh === true ) ? builder.getTypeFromLength( this.getVectorLength() ) : 'float';\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst { min, max } = this;\n\t\tconst { object, geometry } = builder;\n\n\t\tlet output = null;\n\n\t\tif ( object.isInstancedMesh === true ) {\n\n\t\t\tconst vectorLength = this.getVectorLength();\n\t\t\tconst attributeName = 'node' + this.id;\n\n\t\t\tconst length = vectorLength * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tconst attributeGeometry = geometry.getAttribute( attributeName );\n\n\t\t\tif ( attributeGeometry === undefined || attributeGeometry.array.length < length ) {\n\n\t\t\t\tif ( vectorLength === 1 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = MathUtils.lerp( min, max, Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( min.isColor ) {\n\n\t\t\t\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\t\t\t\tarray[ i ] = MathUtils.lerp( min.r, max.r, Math.random() );\n\t\t\t\t\t\tarray[ i + 1 ] = MathUtils.lerp( min.g, max.g, Math.random() );\n\t\t\t\t\t\tarray[ i + 2 ] = MathUtils.lerp( min.b, max.b, Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\t\tconst index = i % vectorLength;\n\n\t\t\t\t\t\tconst minValue = min.getComponent( index );\n\t\t\t\t\t\tconst maxValue = max.getComponent( index );\n\n\t\t\t\t\t\tarray[ i ] = MathUtils.lerp( minValue, maxValue, Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( attributeName, new InstancedBufferAttribute( array, vectorLength ) );\n\n\t\t\t\tgeometry.dispose();\n\n\t\t\t}\n\n\t\t\toutput = attribute( attributeName, builder.getTypeFromLength( vectorLength ) );\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport default RangeNode;\n", "import TempNode from '../core/TempNode.js';\nimport { ShaderNode, uv, add, mul, floor, mod, sign } from '../shadernode/ShaderNodeBaseElements.js';\n\nconst checkerShaderNode = new ShaderNode( ( inputs ) => {\n\n\tconst uv = mul( inputs.uv, 2.0 );\n\n\tconst cx = floor( uv.x );\n\tconst cy = floor( uv.y );\n\tconst result = mod( add( cx, cy ), 2.0 );\n\n\treturn sign( result );\n\n} );\n\nclass CheckerNode extends TempNode {\n\n\tconstructor( uvNode = uv() ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.uvNode = uvNode;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn checkerShaderNode.call( { uv: this.uvNode } ).build( builder );\n\n\t}\n\n}\n\nexport default CheckerNode;\n", "import Node from '../core/Node.js';\nimport MathNode from '../math/MathNode.js';\n\nclass FogNode extends Node {\n\n\tconstructor( colorNode, factorNode ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.isFogNode = true;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.factorNode = factorNode;\n\n\t}\n\n\tmix( outputNode ) {\n\n\t\treturn new MathNode( MathNode.MIX, outputNode, this.colorNode, this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.factorNode.build( builder, 'float' );\n\n\t}\n\n}\n\nexport default FogNode;\n", "import FogNode from './FogNode.js';\nimport { smoothstep, negate, positionView } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass FogRangeNode extends FogNode {\n\n\tconstructor( colorNode, nearNode, farNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.isFogRangeNode = true;\n\n\t\tthis.nearNode = nearNode;\n\t\tthis.farNode = farNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tthis.factorNode = smoothstep( this.nearNode, this.farNode, negate( positionView.z ) );\n\n\t}\n\n}\n\nexport default FogRangeNode;\n", "import FogNode from './FogNode.js';\nimport { sub, exp, mul, negate, positionView } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass FogExp2Node extends FogNode {\n\n\tconstructor( colorNode, densityNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.isFogExp2Node = true;\n\n\t\tthis.densityNode = densityNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst depthNode = negate( positionView.z );\n\t\tconst densityNode = this.densityNode;\n\n\t\tthis.factorNode = sub( 1.0, exp( mul( negate( densityNode ), densityNode, depthNode, depthNode ) ) );\n\n\t}\n\n}\n\nexport default FogExp2Node;\n", "import { ShaderNode, sub } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst F_Schlick = new ShaderNode( ( inputs ) => {\n\n\tconst { f0, f90, dotVH } = inputs;\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();\n\n\treturn f0.mul( sub( 1.0, fresnel ) ).add( f90.mul( fresnel ) );\n\n} ); // validated\n\nexport default F_Schlick;\n", "import { ShaderNode, add, sub, mul, div, pow2, max, sqrt, EPSILON } from '../../shadernode/ShaderNodeBaseElements.js';\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = new ShaderNode( ( inputs ) => {\n\n\tconst { alpha, dotNL, dotNV } = inputs;\n\n\tconst a2 = pow2( alpha );\n\n\tconst gv = mul( dotNL, sqrt( add( a2, mul( sub( 1.0, a2 ), pow2( dotNV ) ) ) ) );\n\tconst gl = mul( dotNV, sqrt( add( a2, mul( sub( 1.0, a2 ), pow2( dotNL ) ) ) ) );\n\n\treturn div( 0.5, max( add( gv, gl ), EPSILON ) );\n\n} ); // validated\n\nexport default V_GGX_SmithCorrelated;\n", "import { ShaderNode, add, sub, mul, div, pow2 } from '../../shadernode/ShaderNodeBaseElements.js';\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney\u2019s reparameterization\nconst D_GGX = new ShaderNode( ( inputs ) => {\n\n\tconst { alpha, dotNH } = inputs;\n\n\tconst a2 = pow2( alpha );\n\n\tconst denom = add( mul( pow2( dotNH ), sub( a2, 1.0 ) ), 1.0 ); // avoid alpha = 0 with dotNH = 1\n\n\treturn mul( 1 / Math.PI, div( a2, pow2( denom ) ) );\n\n} ); // validated\n\nexport default D_GGX;\n", "import F_Schlick from './F_Schlick.js';\nimport V_GGX_SmithCorrelated from './V_GGX_SmithCorrelated.js';\nimport D_GGX from './D_GGX.js';\nimport {\n\tShaderNode, dotNV, add, mul, clamp, dot, pow2, normalize,\n\ttransformedNormalView, positionViewDirection\n} from '../../shadernode/ShaderNodeBaseElements.js';\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = new ShaderNode( ( inputs ) => {\n\n\tconst { lightDirection, f0, f90, roughness } = inputs;\n\n\tconst alpha = pow2( roughness ); // UE4's roughness\n\n\tconst halfDir = normalize( add( lightDirection, positionViewDirection ) );\n\n\tconst dotNL = clamp( dot( transformedNormalView, lightDirection ) );\n\t//const dotNV = clamp( dot( transformedNormalView, positionViewDirection ) );\n\tconst dotNH = clamp( dot( transformedNormalView, halfDir ) );\n\tconst dotVH = clamp( dot( positionViewDirection, halfDir ) );\n\n\tconst F = F_Schlick.call( { f0, f90, dotVH } );\n\n\tconst V = V_GGX_SmithCorrelated.call( { alpha, dotNL, dotNV } );\n\n\tconst D = D_GGX.call( { alpha, dotNH } );\n\n\treturn mul( F, mul( V, D ) );\n\n} ); // validated\n\nexport default BRDF_GGX;\n", "import { ShaderNode, mul } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst BRDF_Lambert = new ShaderNode( ( inputs ) => {\n\n\treturn mul( 1 / Math.PI, inputs.diffuseColor ); // punctual light\n\n} ); // validated\n\nexport default BRDF_Lambert;\n", "import {\n\tShaderNode, dotNV, vec2, vec4, mul, min\n} from '../../shadernode/ShaderNodeElements.js';\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = new ShaderNode( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tconst r = roughness.mul( c0 ).add( c1 );\n\n\tconst a004 = min( mul( r.x, r.x ), dotNV.mul( -9.28 ).exp2() ).mul( r.x ).add( r.y );\n\n\tconst fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );\n\n\treturn fab;\n\n} );\n\nexport default DFGApprox;\n", "import {\n\tShaderNode, div, max, sub, mul, clamp, pow, pow2, pow4, cond, greaterThan\n} from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst getDistanceAttenuation = new ShaderNode( ( inputs ) => {\n\n\tconst { lightDistance, cutoffDistance, decayExponent } = inputs;\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = div( 1.0, max( pow( lightDistance, decayExponent ), 0.01 ) );\n\n\treturn cond(\n\t\tgreaterThan( cutoffDistance, 0 ),\n\t\tmul( distanceFalloff, pow2( clamp( sub( 1.0, pow4( div( lightDistance, cutoffDistance ) ) ) ) ) ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\nexport default getDistanceAttenuation;\n", "import { ShaderNode, max, abs, dFdx, dFdy, normalGeometry } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst getGeometryRoughness = new ShaderNode( () => {\n\n\tconst dxy = max( abs( dFdx( normalGeometry ) ), abs( dFdy( normalGeometry ) ) );\n\tconst geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nexport default getGeometryRoughness;\n", "import getGeometryRoughness from './getGeometryRoughness.js';\nimport { ShaderNode, add, max, min } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst getRoughness = new ShaderNode( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness.call();\n\n\tlet roughnessFactor = max( roughness, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = add( roughnessFactor, geometryRoughness );\n\troughnessFactor = min( roughnessFactor, 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\nexport default getRoughness;\n", "import BRDF_Lambert from './BSDF/BRDF_Lambert.js';\nimport BRDF_GGX from './BSDF/BRDF_GGX.js';\nimport DFGApprox from './BSDF/DFGApprox.js';\nimport {\n\tShaderNode,\n\tvec3, mul, clamp, add, sub, dot, div, transformedNormalView,\n\tpow, exp2, dotNV,\n\tdiffuseColor, specularColor, roughness, temp\n} from '../shadernode/ShaderNodeElements.js';\n\n// Fdez-Ag\u00FCera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nconst computeMultiscattering = ( singleScatter, multiScatter, specularF90 = 1 ) => {\n\n\tconst fab = DFGApprox.call( { roughness } );\n\n\tconst FssEss = add( mul( specularColor, fab.x ), mul( specularF90, fab.y ) );\n\n\tconst Ess = add( fab.x, fab.y );\n\tconst Ems = sub( 1.0, Ess );\n\n\tconst Favg = add( specularColor, mul( sub( 1.0, specularColor ), 0.047619 ) ); // 1/21\n\tconst Fms = div( mul( FssEss, Favg ), sub( 1.0, mul( Ems, Favg ) ) );\n\n\tsingleScatter.add( FssEss );\n\tmultiScatter.add( mul( Fms, Ems ) );\n\n};\n\nconst RE_IndirectSpecular_Physical = new ShaderNode( ( inputs ) => {\n\n\tconst { radiance, iblIrradiance, reflectedLight } = inputs;\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tconst singleScattering = temp( vec3() );\n\tconst multiScattering = temp( vec3() );\n\tconst cosineWeightedIrradiance = mul( iblIrradiance, 1 / Math.PI );\n\n\tcomputeMultiscattering( singleScattering, multiScattering );\n\n\tconst diffuse = mul( diffuseColor, sub( 1.0, add( singleScattering, multiScattering ) ) );\n\n\treflectedLight.indirectSpecular.add( mul( radiance, singleScattering ) );\n\treflectedLight.indirectSpecular.add( mul( multiScattering, cosineWeightedIrradiance ) );\n\n\treflectedLight.indirectDiffuse.add( mul( diffuse, cosineWeightedIrradiance ) );\n\n} );\n\nconst RE_IndirectDiffuse_Physical = new ShaderNode( ( inputs ) => {\n\n\tconst { irradiance, reflectedLight } = inputs;\n\n\treflectedLight.indirectDiffuse.add( mul( irradiance, BRDF_Lambert.call( { diffuseColor } ) ) );\n\n} );\n\nconst RE_Direct_Physical = new ShaderNode( ( inputs ) => {\n\n\tconst { lightDirection, lightColor, reflectedLight } = inputs;\n\n\tconst dotNL = clamp( dot( transformedNormalView, lightDirection ) );\n\tconst irradiance = mul( dotNL, lightColor );\n\n\treflectedLight.directDiffuse.add( mul( irradiance, BRDF_Lambert.call( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\treflectedLight.directSpecular.add( mul( irradiance, BRDF_GGX.call( { lightDirection, f0: specularColor, f90: 1, roughness } ) ) );\n\n} );\n\nconst RE_AmbientOcclusion_Physical = new ShaderNode( ( { ambientOcclusion, reflectedLight } ) => {\n\n\tconst aoNV = add( dotNV, ambientOcclusion );\n\tconst aoExp = exp2( sub( mul( - 16.0, roughness ), 1.0 ) );\n\n\tconst aoNode = clamp( add( sub( pow( aoNV, aoExp ), 1.0 ), ambientOcclusion ) );\n\n\treflectedLight.indirectDiffuse.mul( ambientOcclusion );\n\n\treflectedLight.indirectSpecular.mul( aoNode );\n\n\n} );\n\nconst PhysicalLightingModel = {\n\tdirect: RE_Direct_Physical,\n\tindirectDiffuse: RE_IndirectDiffuse_Physical,\n\tindirectSpecular: RE_IndirectSpecular_Physical,\n\tambientOcclusion: RE_AmbientOcclusion_Physical\n};\n\nexport default PhysicalLightingModel;\n", "import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport { NodeUpdateType } from './constants.js';\n\nimport { REVISION, LinearEncoding, Color, Vector2, Vector3, Vector4 } from 'three';\n\nimport { mul, maxMipLevel } from '../shadernode/ShaderNodeElements.js';\n\nexport const defaultShaderStages = [ 'fragment', 'vertex' ];\nexport const defaultBuildStages = [ 'construct', 'analyze', 'generate' ];\nexport const shaderStages = [ ...defaultShaderStages, 'compute' ];\nexport const vector = [ 'x', 'y', 'z', 'w' ];\n\nconst typeFromLength = new Map();\ntypeFromLength.set( 2, 'vec2' );\ntypeFromLength.set( 3, 'vec3' );\ntypeFromLength.set( 4, 'vec4' );\ntypeFromLength.set( 9, 'mat3' );\ntypeFromLength.set( 16, 'mat4' );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser ) {\n\n\t\tthis.object = object;\n\t\tthis.material = object.material || null;\n\t\tthis.geometry = object.geometry || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.scene = null;\n\t\tthis.lightsNode = null;\n\t\tthis.fogNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.attributes = [];\n\t\tthis.varyings = [];\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flow = { code: '' };\n\t\tthis.stack = [];\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: object.material,\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => mul( levelNode, maxMipLevel( textureNode ) )\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tget node() {\n\n\t\treturn this.stack[ this.stack.length - 1 ];\n\n\t}\n\n\taddStack( node ) {\n\n\t\t/*\n\t\tif ( this.stack.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.stack.push( node );\n\n\t}\n\n\tremoveStack( node ) {\n\n\t\tconst lastStack = this.stack.pop();\n\n\t\tif ( lastStack !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node stack!' );\n\n\t\t}\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.indexOf( node ) === - 1 ) {\n\n\t\t\tconst updateType = node.getUpdateType( this );\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node );\n\n\t\t\t}\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgetTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTextureLevel( /* textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTextureLevel( /* textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t// @TODO: rename to .generateConst()\n\tgetConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst getConst = value => this.getConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry?.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n\n\t}\n\n\tisShaderStage( shaderStage ) {\n\n\t\treturn this.shaderStage === shaderStage;\n\n\t}\n\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tlet encoding;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tencoding = map.texture.encoding;\n\n\t\t} else {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst cache = node.isGlobal( this ) ? this.globalCache : this.cache;\n\n\t\tlet nodeData = cache.getNodeData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t\tcache.setNodeData( node, nodeData );\n\n\t\t}\n\n\t\treturn shaderStage !== null ? nodeData[ shaderStage ] : nodeData;\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tnodeData.properties ||= { outputNode: null };\n\n\t\treturn nodeData.properties;\n\n\t}\n\n\tgetUniformFromNode( node, shaderStage, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( 'nodeUniform' + index, type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ];\n\t\t\tconst index = vars.length;\n\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, null );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tnodeVarying = new NodeVarying( 'nodeVarying' + index, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ];\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: '',\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( const variable of vars ) {\n\n\t\t\tsnippet += `${variable.type} ${variable.name}; `;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tfor ( const nodeCode of codes ) {\n\n\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\t// construct() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\n\t\treturn this;\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n", "import { NodeUpdateType } from './constants.js';\n\nclass NodeFrame {\n\n\tconstructor() {\n\n\t\tthis.time = 0;\n\t\tthis.deltaTime = 0;\n\n\t\tthis.frameId = 0;\n\n\t\tthis.startTime = null;\n\n\t\tthis.updateMap = new WeakMap();\n\n\t\tthis.renderer = null;\n\t\tthis.material = null;\n\t\tthis.camera = null;\n\t\tthis.object = null;\n\n\t}\n\n\tupdateNode( node ) {\n\n\t\tif ( node.updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tif ( this.updateMap.get( node ) !== this.frameId ) {\n\n\t\t\t\tthis.updateMap.set( node, this.frameId );\n\n\t\t\t\tnode.update( this );\n\n\t\t\t}\n\n\t\t} else if ( node.updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\nexport default NodeFrame;\n", "class NodeFunctionInput {\n\n\tconstructor( type, name, count = null, qualifier = '', isConst = false ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.count = count;\n\t\tthis.qualifier = qualifier;\n\t\tthis.isConst = isConst;\n\n\t}\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\nexport default NodeFunctionInput;\n", "import AnalyticLightNode from './AnalyticLightNode.js';\nimport LightsNode from './LightsNode.js';\nimport getDistanceAttenuation from '../functions/light/getDistanceAttenuation.js';\nimport { uniform, positionView, objectViewPosition } from '../shadernode/ShaderNodeElements.js';\n\nimport { PointLight } from 'three';\n\nclass PointLightNode extends AnalyticLightNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.cutoffDistanceNode = uniform( 0 );\n\t\tthis.decayExponentNode = uniform( 0 );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lVector = objectViewPosition( light ).sub( positionView );\n\n\t\tconst lightDirection = lVector.normalize();\n\t\tconst lightDistance = lVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation.call( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tconst lightColor = colorNode.mul( lightAttenuation );\n\n\t\tconst lightingModelFunctionNode = builder.context.lightingModelNode;\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tif ( lightingModelFunctionNode?.direct ) {\n\n\t\t\tlightingModelFunctionNode.direct.call( {\n\t\t\t\tlightDirection,\n\t\t\t\tlightColor,\n\t\t\t\treflectedLight\n\t\t\t}, builder );\n\n\t\t}\n\n\t}\n\n}\n\nLightsNode.setReference( PointLight, PointLightNode );\n\nexport default PointLightNode;\n", "import { Vector3 } from 'three';\n\nlet vector3;\n\nconst getDirectionVector = ( light, camera, directionVector ) => {\n\n\tvector3 ||= new Vector3();\n\n\tdirectionVector.setFromMatrixPosition( light.matrixWorld );\n\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\tdirectionVector.sub( vector3 );\n\tdirectionVector.transformDirection( camera.matrixWorldInverse );\n\n}\n\nexport default getDirectionVector;\n", "import AnalyticLightNode from './AnalyticLightNode.js';\nimport LightsNode from './LightsNode.js';\nimport getDirectionVector from '../functions/light/getDirectionVector.js';\nimport { uniform } from '../shadernode/ShaderNodeElements.js';\n\nimport { Vector3, DirectionalLight } from 'three';\n\nclass DirectionalLightNode extends AnalyticLightNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.directionNode = uniform( new Vector3() );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tgetDirectionVector( this.light, frame.camera, this.directionNode.value );\n\n\t\tsuper.update( frame );\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst lightDirection = this.directionNode.normalize();\n\t\tconst lightColor = this.colorNode;\n\n\t\tconst lightingModelFunctionNode = builder.context.lightingModelNode;\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tif ( lightingModelFunctionNode?.direct ) {\n\n\t\t\tlightingModelFunctionNode.direct.call( {\n\t\t\t\tlightDirection,\n\t\t\t\tlightColor,\n\t\t\t\treflectedLight\n\t\t\t}, builder );\n\n\t\t}\n\n\t}\n\n}\n\nLightsNode.setReference( DirectionalLight, DirectionalLightNode );\n\nexport default DirectionalLightNode;\n", "import AnalyticLightNode from './AnalyticLightNode.js';\nimport LightsNode from './LightsNode.js';\nimport getDistanceAttenuation from '../functions/light/getDistanceAttenuation.js';\nimport getDirectionVector from '../functions/light/getDirectionVector.js';\nimport { uniform, smoothstep, positionView, objectViewPosition } from '../shadernode/ShaderNodeElements.js';\n\nimport { Vector3, SpotLight } from 'three';\n\nconst getSpotAttenuation = ( coneCosine, penumbraCosine, angleCosine ) => smoothstep( coneCosine, penumbraCosine, angleCosine );\n\nclass SpotLightNode extends AnalyticLightNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.directionNode = uniform( new Vector3() );\n\n\t\tthis.coneCosNode = uniform( 0 );\n\t\tthis.penumbraCosNode = uniform( 0 );\n\n\t\tthis.cutoffDistanceNode = uniform( 0 );\n\t\tthis.decayExponentNode = uniform( 0 );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tgetDirectionVector( light, frame.camera, this.directionNode.value );\n\n\t\tthis.coneCosNode.value = Math.cos( light.angle );\n\t\tthis.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lVector = objectViewPosition( light ).sub( positionView );\n\n\t\tconst lightDirection = lVector.normalize();\n\t\tconst angleCos = lightDirection.dot( this.directionNode )\n\t\tconst spotAttenuation = getSpotAttenuation( this.coneCosNode, this.penumbraCosNode, angleCos );\n\n\t\tconst lightDistance = lVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation.call( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tconst finalColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );\n\n\t\tconst lightColor = spotAttenuation.greaterThan( 0 ).cond( finalColor, 0 );\n\n\t\tconst lightingModelFunctionNode = builder.context.lightingModelNode;\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tif ( lightingModelFunctionNode?.direct ) {\n\n\t\t\tlightingModelFunctionNode.direct.call( {\n\t\t\t\tlightDirection,\n\t\t\t\tlightColor,\n\t\t\t\treflectedLight\n\t\t\t}, builder );\n\n\t\t}\n\n\t}\n\n}\n\nLightsNode.setReference( SpotLight, SpotLightNode );\n\nexport default SpotLightNode;\n", "import AnalyticLightNode from './AnalyticLightNode.js';\nimport LightsNode from './LightsNode.js';\n\nimport { AmbientLight } from 'three';\n\nclass AmbientLightNode extends AnalyticLightNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tconstruct( { context } ) {\n\n\t\tcontext.irradiance.add( this.colorNode );\n\n\t}\n\n}\n\nLightsNode.setReference( AmbientLight, AmbientLightNode );\n\nexport default AmbientLightNode;\n", "import AnalyticLightNode from './AnalyticLightNode.js';\nimport LightsNode from './LightsNode.js';\nimport Object3DNode from '../accessors/Object3DNode.js';\nimport { uniform, add, mul, dot, mix, normalize, normalView } from '../shadernode/ShaderNodeElements.js';\n\nimport { Color, HemisphereLight } from 'three';\n\nclass HemisphereLightNode extends AnalyticLightNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.lightPositionNode = new Object3DNode( Object3DNode.POSITION );\n\t\tthis.lightDirectionNode = normalize( this.lightPositionNode );\n\n\t\tthis.groundColorNode = uniform( new Color() );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.lightPositionNode.object3d = light;\n\n\t\tthis.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { colorNode, groundColorNode, lightDirectionNode } = this;\n\n\t\tconst dotNL = dot( normalView, lightDirectionNode );\n\t\tconst hemiDiffuseWeight = add( mul( 0.5, dotNL ), 0.5 );\n\n\t\tconst irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );\n\n\t\tbuilder.context.irradiance.add( irradiance );\n\n\t}\n\n}\n\nLightsNode.setReference( HemisphereLight, HemisphereLightNode );\n\nexport default HemisphereLightNode;\n", "import LightingNode from './LightingNode.js';\nimport ContextNode from '../core/ContextNode.js';\nimport CacheNode from '../core/CacheNode.js';\nimport SpecularMIPLevelNode from '../utils/SpecularMIPLevelNode.js';\nimport { float, mul, roughness, positionViewDirection, transformedNormalView, transformedNormalWorld, cameraViewMatrix, equirectUV, vec2 } from '../shadernode/ShaderNodeElements.js';\n\nclass EnvironmentNode extends LightingNode {\n\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst envNode = this.envNode;\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet reflectVec;\n\t\tlet radianceTextureUVNode;\n\t\tlet irradianceTextureUVNode;\n\n\t\tconst radianceContext = new ContextNode( envNode, {\n\t\t\tgetUVNode: ( textureNode ) => {\n\n\t\t\t\tlet node = null;\n\n\t\t\t\tif ( reflectVec === undefined ) {\n\n\t\t\t\t\treflectVec = positionViewDirection.negate().reflect( transformedNormalView );\n\t\t\t\t\treflectVec = reflectVec.mix( transformedNormalView, roughness.mul( roughness ) ).normalize();\n\t\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureNode.isCubeTextureNode ) {\n\n\t\t\t\t\tnode = reflectVec;\n\n\t\t\t\t} else if ( textureNode.isTextureNode ) {\n\n\t\t\t\t\tif ( radianceTextureUVNode === undefined ) {\n\n\t\t\t\t\t\t// @TODO: Needed PMREM\n\n\t\t\t\t\t\tradianceTextureUVNode = equirectUV( reflectVec );\n\t\t\t\t\t\tradianceTextureUVNode = vec2( radianceTextureUVNode.x, radianceTextureUVNode.y.invert() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode = radianceTextureUVNode;\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t},\n\t\t\tgetSamplerLevelNode: () => {\n\n\t\t\t\treturn roughness;\n\n\t\t\t},\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => {\n\n\t\t\t\treturn new SpecularMIPLevelNode( textureNode, levelNode );\n\n\t\t\t}\n\t\t} );\n\n\t\tconst irradianceContext = new ContextNode( envNode, {\n\t\t\tgetUVNode: ( textureNode ) => {\n\n\t\t\t\tlet node = null;\n\n\t\t\t\tif ( textureNode.isCubeTextureNode ) {\n\n\t\t\t\t\tnode = transformedNormalWorld;\n\n\t\t\t\t} else if ( textureNode.isTextureNode ) {\n\n\t\t\t\t\tif ( irradianceTextureUVNode === undefined ) {\n\n\t\t\t\t\t\t// @TODO: Needed PMREM\n\n\t\t\t\t\t\tirradianceTextureUVNode = equirectUV( transformedNormalWorld );\n\t\t\t\t\t\tirradianceTextureUVNode = vec2( irradianceTextureUVNode.x, irradianceTextureUVNode.y.invert() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode = irradianceTextureUVNode;\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t},\n\t\t\tgetSamplerLevelNode: () => {\n\n\t\t\t\treturn float( 1 );\n\n\t\t\t},\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => {\n\n\t\t\t\treturn new SpecularMIPLevelNode( textureNode, levelNode );\n\n\t\t\t}\n\t\t} );\n\n\t\t//\n\n\t\tconst isolateRadianceFlowContext = new CacheNode( radianceContext );\n\n\t\t//\n\n\t\tbuilder.context.radiance.add( isolateRadianceFlowContext );\n\n\t\tbuilder.context.iblIrradiance.add( mul( Math.PI, irradianceContext ) );\n\n\t\tproperties.radianceContext = isolateRadianceFlowContext;\n\t\tproperties.irradianceContext = irradianceContext;\n\n\t}\n\n}\n\nexport default EnvironmentNode;\n", "import LightingNode from './LightingNode.js';\nimport { float, add, mul, sub } from '../shadernode/ShaderNodeElements.js';\n\nclass AONode extends LightingNode {\n\n\tconstructor( aoNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.aoNode = aoNode;\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst aoIntensity = 1;\n\t\tconst aoNode = add( mul( sub( float( this.aoNode ), 1.0 ), aoIntensity ), 1.0 );\n\n\t\tbuilder.context.ambientOcclusion.mul( aoNode );\n\n\t}\n\n}\n\nexport default AONode;\n", "import * as Nodes from '../Nodes.js';\nimport { FileLoader, Loader } from 'three';\n\nclass NodeLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( text ) => {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( this.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparseNodes( json ) {\n\n\t\tconst nodes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tconst { uuid, type } = nodeJSON;\n\n\t\t\t\tnodes[ uuid ] = Nodes.fromType( type );\n\t\t\t\tnodes[ uuid ].uuid = uuid;\n\n\t\t\t}\n\n\t\t\tconst meta = { nodes, textures: this.textures };\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tnodeJSON.meta = meta;\n\n\t\t\t\tconst node = nodes[ nodeJSON.uuid ];\n\t\t\t\tnode.deserialize( nodeJSON );\n\n\t\t\t\tdelete nodeJSON.meta;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst node = Nodes.fromType( json.type );\n\t\tnode.uuid = json.uuid;\n\n\t\tconst nodes = this.parseNodes( json.inputNodes );\n\t\tconst meta = { nodes, textures: this.textures };\n\n\t\tjson.meta = meta;\n\n\t\tnode.deserialize( json );\n\n\t\tdelete json.meta;\n\n\t\treturn node;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n}\n\nexport default NodeLoader;\n", "import { Material, ShaderMaterial } from 'three';\nimport { getNodesKeys, getCacheKey } from '../core/NodeUtils.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport {\n\tfloat, vec3, vec4,\n\tassign, label, mul, bypass, attribute,\n\tpositionLocal, skinning, instance, modelViewProjection, lightingContext, colorSpace,\n\tmaterialAlphaTest, materialColor, materialOpacity, reference, rangeFog, exp2Fog\n} from '../shadernode/ShaderNodeElements.js';\n\nclass NodeMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.type = this.constructor.name;\n\n\t\tthis.lights = true;\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.generatePosition( builder );\n\n\t\tconst { lightsNode } = this;\n\t\tconst { diffuseColorNode } = this.generateDiffuseColor( builder );\n\n\t\tconst outgoingLightNode = this.generateLight( builder, { diffuseColorNode, lightsNode } );\n\n\t\tthis.generateOutput( builder, { diffuseColorNode, outgoingLightNode } );\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n\tgeneratePosition( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\t// < VERTEX STAGE >\n\n\t\tlet vertex = positionLocal;\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tvertex = bypass( vertex, assign( positionLocal, this.positionNode ) );\n\n\t\t}\n\n\t\tif ( object.instanceMatrix?.isInstancedBufferAttribute === true && builder.isAvailable( 'instance' ) === true ) {\n\n\t\t\tvertex = bypass( vertex, instance( object ) );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tvertex = bypass( vertex, skinning( object ) );\n\n\t\t}\n\n\t\tbuilder.context.vertex = vertex;\n\n\t\tbuilder.addFlow( 'vertex', modelViewProjection() );\n\n\t}\n\n\tgenerateDiffuseColor( builder ) {\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tlet colorNode = vec4( this.colorNode || materialColor );\n\t\tlet opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && builder.geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( mul( colorNode.xyz, attribute( 'color' ) ), colorNode.a );\n\t\t\n\t\t}\n\n\t\t// COLOR\n\n\t\tcolorNode = builder.addFlow( 'fragment', label( colorNode, 'Color' ) );\n\t\tconst diffuseColorNode = builder.addFlow( 'fragment', label( colorNode, 'DiffuseColor' ) );\n\n\t\t// OPACITY\n\n\t\topacityNode = builder.addFlow( 'fragment', label( opacityNode, 'OPACITY' ) );\n\t\tbuilder.addFlow( 'fragment', assign( diffuseColorNode.a, mul( diffuseColorNode.a, opacityNode ) ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tbuilder.addFlow( 'fragment', label( alphaTestNode, 'AlphaTest' ) );\n\n\t\t\t// @TODO: remove ExpressionNode here and then possibly remove it completely\n\t\t\tbuilder.addFlow( 'fragment', new ExpressionNode( 'if ( DiffuseColor.a <= AlphaTest ) { discard; }' ) );\n\n\t\t}\n\n\t\treturn { colorNode, diffuseColorNode };\n\n\t}\n\n\tgenerateLight( builder, { diffuseColorNode, lightingModelNode, lightsNode = builder.lightsNode } ) {\n\n\t\t// < ANALYTIC LIGHTS >\n\n\t\t// OUTGOING LIGHT\n\n\t\tlet outgoingLightNode = diffuseColorNode.xyz;\n\t\tif ( lightsNode && lightsNode.hasLight !== false ) outgoingLightNode = builder.addFlow( 'fragment', label( lightingContext( lightsNode, lightingModelNode ), 'Light' ) );\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tgenerateOutput( builder, { diffuseColorNode, outgoingLightNode } ) {\n\n\t\t// OUTPUT\n\n\t\tlet outputNode = vec4( outgoingLightNode, diffuseColorNode.a );\n\n\t\t// ENCODING\n\n\t\toutputNode = colorSpace( outputNode, builder.renderer.outputEncoding );\n\n\t\t// FOG\n\n\t\tlet fogNode = builder.fogNode;\n\n\t\tif ( fogNode?.isNode !== true && builder.scene.fog ) {\n\n\t\t\tconst fog = builder.scene.fog;\n\n\t\t\tif ( fog.isFogExp2 ) {\n\n\t\t\t\tfogNode = exp2Fog( reference( 'color', 'color', fog ), reference( 'density', 'float', fog ) );\n\n\t\t\t} else if ( fog.isFog ) {\n\n\t\t\t\tfogNode = rangeFog( reference( 'color', 'color', fog ), reference( 'near', 'float', fog ), reference( 'far', 'float', fog ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'NodeMaterial: Unsupported fog configuration.', fog );\n\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif ( fogNode ) outputNode = vec4( vec3( fogNode.mix( outputNode ) ), outputNode.w );\n\n\t\t// RESULT\n\n\t\tbuilder.addFlow( 'fragment', label( outputNode, 'Output' ) );\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( values ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in values ) {\n\n\t\t\tconst value = values[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value?.clone?.() || value;\n\n\t\t\t}\n\n\t\t}\n\n\t\tObject.assign( this.defines, values.defines );\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const name of nodeKeys ) {\n\n\t\t\tdata.inputNodes[ name ] = this[ name ].toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromMaterial( /*material*/ ) { }\n\n}\n\nexport default NodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { LineBasicMaterial } from 'three';\n\nconst defaultValues = new LineBasicMaterial();\n\nclass LineBasicNodeMaterial extends NodeMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicNodeMaterial = true;\n\n\t\tthis.colorNode = null;\n\t\tthis.opacityNode = null;\n\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.lightNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.opacityNode = source.opacityNode;\n\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.lightNode = source.lightNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nexport default LineBasicNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { MeshBasicMaterial } from 'three';\n\nconst defaultValues = new MeshBasicMaterial();\n\nclass MeshBasicNodeMaterial extends NodeMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicNodeMaterial = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.colorNode = null;\n\t\tthis.opacityNode = null;\n\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.lightNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.opacityNode = source.opacityNode;\n\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.lightNode = source.lightNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nexport default MeshBasicNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport {\n\tfloat, vec3, vec4, normalView, add, context,\n\tassign, label, mul, invert, mix, texture, uniform,\n\tmaterialRoughness, materialMetalness, materialEmissive\n} from '../shadernode/ShaderNodeElements.js';\nimport LightsNode from '../lighting/LightsNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nimport AONode from '../lighting/AONode.js';\nimport getRoughness from '../functions/material/getRoughness.js';\nimport PhysicalLightingModel from '../functions/PhysicalLightingModel.js';\nimport NormalMapNode from '../display/NormalMapNode.js';\n\nimport { MeshStandardMaterial } from 'three';\n\nconst defaultValues = new MeshStandardMaterial();\n\nexport default class MeshStandardNodeMaterial extends NodeMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardNodeMaterial = true;\n\n\t\tthis.colorNode = null;\n\t\tthis.opacityNode = null;\n\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.normalNode = null;\n\n\t\tthis.emissiveNode = null;\n\n\t\tthis.metalnessNode = null;\n\t\tthis.roughnessNode = null;\n\n\t\tthis.envNode = null;\n\n\t\tthis.lightsNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.generatePosition( builder );\n\n\t\tconst colorNodes = this.generateDiffuseColor( builder );\n\t\tconst { colorNode } = colorNodes;\n\t\tlet { diffuseColorNode } = colorNodes;\n\n\t\tconst envNode = this.envNode || builder.scene.environmentNode;\n\n\t\tdiffuseColorNode = this.generateStandardMaterial( builder, { colorNode, diffuseColorNode } );\n\n\t\tif ( this.lightsNode ) builder.lightsNode = this.lightsNode;\n\n\t\tconst materialLightsNode = [];\n\n\t\tif ( envNode ) {\n\n\t\t\tmaterialLightsNode.push( new EnvironmentNode( envNode ) );\n\n\t\t}\n\n\t\tif ( builder.material.aoMap ) {\n\n\t\t\tmaterialLightsNode.push( new AONode( texture( builder.material.aoMap ) ) );\n\n\t\t}\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tbuilder.lightsNode = new LightsNode( [ ...builder.lightsNode.lightNodes, ...materialLightsNode ] );\n\n\t\t}\n\n\t\tconst outgoingLightNode = this.generateLight( builder, { diffuseColorNode, lightingModelNode: PhysicalLightingModel } );\n\n\t\tthis.generateOutput( builder, { diffuseColorNode, outgoingLightNode } );\n\n\t}\n\n\tgenerateStandardMaterial( builder, { colorNode, diffuseColorNode } ) {\n\n\t\tconst { material } = builder;\n\n\t\t// METALNESS\n\n\t\tlet metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;\n\n\t\tmetalnessNode = builder.addFlow( 'fragment', label( metalnessNode, 'Metalness' ) );\n\t\tbuilder.addFlow( 'fragment', assign( diffuseColorNode, vec4( mul( diffuseColorNode.rgb, invert( metalnessNode ) ), diffuseColorNode.a ) ) );\n\n\t\t// ROUGHNESS\n\n\t\tlet roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;\n\t\troughnessNode = getRoughness.call( { roughness: roughnessNode } );\n\n\t\tbuilder.addFlow( 'fragment', label( roughnessNode, 'Roughness' ) );\n\n\t\t// SPECULAR COLOR\n\n\t\tconst specularColorNode = mix( vec3( 0.04 ), colorNode.rgb, metalnessNode );\n\n\t\tbuilder.addFlow( 'fragment', label( specularColorNode, 'SpecularColor' ) );\n\n\t\t// NORMAL VIEW\n\n\t\tconst normalNode = this.normalNode ? vec3( this.normalNode ) : ( material.normalMap ? new NormalMapNode( texture( material.normalMap ), uniform( material.normalScale ) ) : normalView );\n\n\t\tbuilder.addFlow( 'fragment', label( normalNode, 'TransformedNormalView' ) );\n\n\t\treturn diffuseColorNode;\n\n\t}\n\n\tgenerateLight( builder, { diffuseColorNode, lightingModelNode, lightsNode = builder.lightsNode } ) {\n\n\t\tconst renderer = builder.renderer;\n\n\t\t// OUTGOING LIGHT\n\n\t\tlet outgoingLightNode = super.generateLight( builder, { diffuseColorNode, lightingModelNode, lightsNode } );\n\n\t\t// EMISSIVE\n\n\t\toutgoingLightNode = add( vec3( this.emissiveNode || materialEmissive ), outgoingLightNode );\n\n\t\t// TONE MAPPING\n\n\t\tif ( renderer.toneMappingNode ) outgoingLightNode = context( renderer.toneMappingNode, { color: outgoingLightNode } );\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.opacityNode = source.opacityNode;\n\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.normalNode = source.normalNode;\n\n\t\tthis.emissiveNode = source.emissiveNode;\n\n\t\tthis.metalnessNode = source.metalnessNode;\n\t\tthis.roughnessNode = source.roughnessNode;\n\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.lightsNode = source.lightsNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n", "import MeshStandardNodeMaterial from './MeshStandardNodeMaterial.js';\n\nimport { MeshPhysicalMaterial } from 'three';\n\nconst defaultValues = new MeshPhysicalMaterial();\n\nexport default class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalNodeMaterial = true;\n\n\t\tthis.clearcoatNode = null;\n\t\tthis.clearcoatRoughnessNode = null;\n\t\tthis.clearcoatNormalNode = null;\n\n\t\tthis.sheenNode = null;\n\t\tthis.sheenRoughnessNode = null;\n\n\t\tthis.iridescenceNode = null;\n\t\tthis.iridescenceIORNode = null;\n\t\tthis.iridescenceThicknessNode = null;\n\n\t\tthis.specularIntensityNode = null;\n\t\tthis.specularColorNode = null;\n\n\t\tthis.transmissionNode = null;\n\t\tthis.thicknessNode = null;\n\t\tthis.attenuationDistanceNode = null;\n\t\tthis.attenuationColorNode = null;\n\n\t\tthis.sheen = 0;\n\t\tthis.clearcoat = 0;\n\t\tthis.iridescence = 0;\n\t\tthis.transmission = 0;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.clearcoatNode = source.clearcoatNode;\n\t\tthis.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n\t\tthis.clearcoatNormalNode = source.clearcoatNormalNode;\n\n\t\tthis.sheenNode = source.sheenNode;\n\t\tthis.sheenRoughnessNode = source.sheenRoughnessNode;\n\n\t\tthis.iridescenceNode = source.iridescenceNode;\n\t\tthis.iridescenceIORNode = source.iridescenceIORNode;\n\t\tthis.iridescenceThicknessNode = source.iridescenceThicknessNode;\n\n\t\tthis.specularIntensityNode = source.specularIntensityNode;\n\t\tthis.specularColorNode = source.specularColorNode;\n\n\t\tthis.transmissionNode = source.transmissionNode;\n\t\tthis.thicknessNode = source.thicknessNode;\n\t\tthis.attenuationDistanceNode = source.attenuationDistanceNode;\n\t\tthis.attenuationColorNode = source.attenuationColorNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n", "import NodeMaterial from './NodeMaterial.js';\nimport { PointsMaterial } from 'three';\n\nconst defaultValues = new PointsMaterial();\n\nclass PointsNodeMaterial extends NodeMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.colorNode = null;\n\t\tthis.opacityNode = null;\n\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.lightNode = null;\n\n\t\tthis.sizeNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.opacityNode = source.opacityNode;\n\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.lightNode = source.lightNode;\n\n\t\tthis.sizeNode = source.sizeNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nexport default PointsNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { SpriteMaterial } from 'three';\nimport {\n\tvec2, vec3, vec4,\n\tuniform, add, mul, sub,\n\tpositionLocal, length, cos, sin,\n\tmodelViewMatrix, cameraProjectionMatrix, modelWorldMatrix, materialRotation\n} from '../shadernode/ShaderNodeElements.js';\n\nconst defaultValues = new SpriteMaterial();\n\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.colorNode = null;\n\t\tthis.opacityNode = null;\n\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.lightNode = null;\n\n\t\tthis.positionNode = null;\n\t\tthis.rotationNode = null;\n\t\tthis.scaleNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tgeneratePosition( builder ) {\n\n\t\t// < VERTEX STAGE >\n\n\t\tconst { positionNode, rotationNode, scaleNode } = this;\n\n\t\tconst vertex = positionLocal;\n\n\t\tlet mvPosition = mul( modelViewMatrix, positionNode ? vec4( positionNode.xyz, 1 ) : vec4( 0, 0, 0, 1 ) );\n\n\t\tlet scale = vec2(\n\t\t\tlength( vec3( modelWorldMatrix[ 0 ].x, modelWorldMatrix[ 0 ].y, modelWorldMatrix[ 0 ].z ) ),\n\t\t\tlength( vec3( modelWorldMatrix[ 1 ].x, modelWorldMatrix[ 1 ].y, modelWorldMatrix[ 1 ].z ) )\n\t\t);\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = mul( scale, scaleNode );\n\n\t\t}\n\n\t\tlet alignedPosition = vertex.xy;\n\n\t\tif ( builder.object.center?.isVector2 === true ) {\n\n\t\t\talignedPosition = sub( alignedPosition, sub( uniform( builder.object.center ), vec2( 0.5 ) ) );\n\n\t\t}\n\n\t\talignedPosition = mul( alignedPosition, scale );\n\n\t\tconst rotation = rotationNode || materialRotation;\n\n\t\tconst rotatedPosition = vec2(\n\t\t\tsub( mul( cos( rotation ), alignedPosition.x ), mul( sin( rotation ), alignedPosition.y ) ),\n\t\t\tadd( mul( sin( rotation ), alignedPosition.x ), mul( cos( rotation ), alignedPosition.y ) )\n\t\t);\n\n\t\tmvPosition = vec4( add( mvPosition.xy, rotatedPosition.xy ), mvPosition.z, mvPosition.w );\n\n\t\tconst modelViewProjection = mul( cameraProjectionMatrix, mvPosition );\n\n\t\tbuilder.context.vertex = vertex;\n\n\t\tbuilder.addFlow( 'vertex', modelViewProjection );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.opacityNode = source.opacityNode;\n\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.lightNode = source.lightNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nexport default SpriteNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport LineBasicNodeMaterial from './LineBasicNodeMaterial.js';\nimport MeshBasicNodeMaterial from './MeshBasicNodeMaterial.js';\nimport MeshStandardNodeMaterial from './MeshStandardNodeMaterial.js';\nimport MeshPhysicalNodeMaterial from './MeshPhysicalNodeMaterial.js';\nimport PointsNodeMaterial from './PointsNodeMaterial.js';\nimport SpriteNodeMaterial from './SpriteNodeMaterial.js';\n\nexport {\n\tNodeMaterial,\n\tLineBasicNodeMaterial,\n\tMeshBasicNodeMaterial,\n\tMeshStandardNodeMaterial,\n\tMeshPhysicalNodeMaterial,\n\tPointsNodeMaterial,\n\tSpriteNodeMaterial\n};\n\nNodeMaterial.fromMaterial = function ( material ) {\n\n\tconst materialLib = {\n\t\tNodeMaterial,\n\t\tLineBasicNodeMaterial,\n\t\tMeshBasicNodeMaterial,\n\t\tMeshStandardNodeMaterial,\n\t\tMeshPhysicalNodeMaterial,\n\t\tPointsNodeMaterial,\n\t\tSpriteNodeMaterial\n\t};\n\n\tconst type = material.type.replace( 'Material', 'NodeMaterial' );\n\n\tif ( materialLib[ type ] === undefined ) {\n\n\t\tif ( material.isNodeMaterial !== true ) {\n\n\t\t\tthrow new Error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t}\n\n\t\treturn material; // is already a node material\n\n\t}\n\n\tconst nodeMaterial = new materialLib[ type ]();\n\n\tfor ( const key in material ) {\n\n\t\tnodeMaterial[ key ] = material[ key ];\n\n\t}\n\n\treturn nodeMaterial;\n\n};\n", "import { MaterialLoader } from 'three';\nimport {\n\tNodeMaterial,\n\tLineBasicNodeMaterial,\n\tMeshBasicNodeMaterial,\n\tMeshStandardNodeMaterial,\n\tMeshPhysicalNodeMaterial,\n\tPointsNodeMaterial,\n\tSpriteNodeMaterial\n} from '../materials/Materials.js';\n\nconst superFromTypeFunction = MaterialLoader.createMaterialFromType;\n\nMaterialLoader.createMaterialFromType = function ( type ) {\n\n\tconst materialLib = {\n\t\tNodeMaterial,\n\t\tLineBasicNodeMaterial,\n\t\tMeshBasicNodeMaterial,\n\t\tMeshStandardNodeMaterial,\n\t\tMeshPhysicalNodeMaterial,\n\t\tPointsNodeMaterial,\n\t\tSpriteNodeMaterial\n\t};\n\n\tif ( materialLib[ type ] !== undefined ) {\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n\treturn superFromTypeFunction.call( this, type );\n\n};\n\nclass NodeMaterialLoader extends MaterialLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.nodes = {};\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst material = super.parse( json );\n\n\t\tconst nodes = this.nodes;\n\t\tconst inputNodes = json.inputNodes;\n\n\t\tfor ( const property in inputNodes ) {\n\n\t\t\tconst uuid = inputNodes[ property ];\n\n\t\t\tmaterial[ property ] = nodes[ uuid ];\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport default NodeMaterialLoader;\n", "import NodeLoader from './NodeLoader.js';\nimport NodeMaterialLoader from './NodeMaterialLoader.js';\nimport { ObjectLoader } from 'three';\n\nclass NodeObjectLoader extends ObjectLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis._nodesJSON = null;\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tthis._nodesJSON = json.nodes;\n\n\t\tconst data = super.parse( json, onLoad );\n\n\t\tthis._nodesJSON = null; // dispose\n\n\t\treturn data;\n\n\t}\n\n\tparseNodes( json, textures ) {\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new NodeLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\treturn loader.parseNodes( json );\n\n\t\t}\n\n\t\treturn {};\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst nodes = this.parseNodes( this._nodesJSON, textures );\n\n\t\t\tconst loader = new NodeMaterialLoader();\n\t\t\tloader.setTextures( textures );\n\t\t\tloader.setNodes( nodes );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n}\n\nexport default NodeObjectLoader;\n", "class NodeParser {\n\n\tparseFunction( /*source*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nexport default NodeParser;\n", "class NodeFunction {\n\n\tconstructor( type, inputs, name = '', presicion = '' ) {\n\n\t\tthis.type = type;\n\t\tthis.inputs = inputs;\n\t\tthis.name = name;\n\t\tthis.presicion = presicion;\n\n\t}\n\n\tgetCode( /*name = this.name*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nNodeFunction.isNodeFunction = true;\n\nexport default NodeFunction;\n", "import NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+)?/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\n\nconst wgslTypeLib = {\n\tf32: 'float'\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\t// default\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\t\t\tlet type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\ttype = wgslTypeLib[ type ] || type;\n\n\t\t\t// precision\n\n\t\t\tif ( i < propsMatches.length && /^[fui]\\d{2}$/.test( propsMatches[ i ][ 0 ] ) === true )\n\t\t\t\ti ++;\n\n\t\t\t// add input\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = declaration[ 3 ] || 'void';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\nclass WGSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tconst type = this.type !== 'void' ? '-> ' + this.type : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ type }` + this.blockCode;\n\n\t}\n\n}\n\nexport default WGSLNodeFunction;\n", "import NodeParser from '../core/NodeParser.js';\nimport WGSLNodeFunction from './WGSLNodeFunction.js';\n\nclass WGSLNodeParser extends NodeParser {\n\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\nexport default WGSLNodeParser;\n", "import NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst presicion = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tpresicion,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\nclass GLSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse( source );\n\n\t\tsuper( type, inputs, name, presicion );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, presicion } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( presicion !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ presicion } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\nexport default GLSLNodeFunction;\n", "import NodeParser from '../core/NodeParser.js';\nimport GLSLNodeFunction from './GLSLNodeFunction.js';\n\nclass GLSLNodeParser extends NodeParser {\n\n\tparseFunction( source ) {\n\n\t\treturn new GLSLNodeFunction( source );\n\n\t}\n\n}\n\nexport default GLSLNodeParser;\n", "import { code, fn } from '../../Nodes.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\nexport const mx_noise = code( `float mx_select(bool b, float t, float f)\n{\n    return b ? t : f;\n}\n\nfloat mx_negate_if(float val, bool b)\n{\n    return b ? -val : val;\n}\n\nint mx_floor(float x)\n{\n    return int(floor(x));\n}\n\n// return mx_floor as well as the fractional remainder\nfloat mx_floorfrac(float x, out int i)\n{\n    i = mx_floor(x);\n    return x - float(i);\n}\n\nfloat mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)\n{\n    float s1 = 1.0 - s;\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\n}\nvec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)\n{\n    float s1 = 1.0 - s;\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\n}\nfloat mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)\n{\n    float s1 = 1.0 - s;\n    float t1 = 1.0 - t;\n    float r1 = 1.0 - r;\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\n}\nvec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)\n{\n    float s1 = 1.0 - s;\n    float t1 = 1.0 - t;\n    float r1 = 1.0 - r;\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\n}\n\n// 2 and 3 dimensional gradient functions - perform a dot product against a\n// randomly chosen vector. Note that the gradient vector is not normalized, but\n// this only affects the overal \"scale\" of the result, so we simply account for\n// the scale by multiplying in the corresponding \"perlin\" function.\nfloat mx_gradient_float(uint hash, float x, float y)\n{\n    // 8 possible directions (+-1,+-2) and (+-2,+-1)\n    uint h = hash & 7u;\n    float u = mx_select(h<4u, x, y);\n    float v = 2.0 * mx_select(h<4u, y, x);\n    // compute the dot product with (x,y).\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\n}\nfloat mx_gradient_float(uint hash, float x, float y, float z)\n{\n    // use vectors pointing to the edges of the cube\n    uint h = hash & 15u;\n    float u = mx_select(h<8u, x, y);\n    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\n}\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y)\n{\n    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\n}\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)\n{\n    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\n}\n// Scaling factors to normalize the result of gradients above.\n// These factors were experimentally calculated to be:\n//    2D:   0.6616\n//    3D:   0.9820\nfloat mx_gradient_scale2d(float v) { return 0.6616 * v; }\nfloat mx_gradient_scale3d(float v) { return 0.9820 * v; }\nvec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }\nvec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }\n\n/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)\nuint mx_rotl32(uint x, int k)\n{\n    return (x<<k) | (x>>(32-k));\n}\n\nvoid mx_bjmix(inout uint a, inout uint b, inout uint c)\n{\n    a -= c; a ^= mx_rotl32(c, 4); c += b;\n    b -= a; b ^= mx_rotl32(a, 6); a += c;\n    c -= b; c ^= mx_rotl32(b, 8); b += a;\n    a -= c; a ^= mx_rotl32(c,16); c += b;\n    b -= a; b ^= mx_rotl32(a,19); a += c;\n    c -= b; c ^= mx_rotl32(b, 4); b += a;\n}\n\n// Mix up and combine the bits of a, b, and c (doesn't change them, but\n// returns a hash of those three original values).\nuint mx_bjfinal(uint a, uint b, uint c)\n{\n    c ^= b; c -= mx_rotl32(b,14);\n    a ^= c; a -= mx_rotl32(c,11);\n    b ^= a; b -= mx_rotl32(a,25);\n    c ^= b; c -= mx_rotl32(b,16);\n    a ^= c; a -= mx_rotl32(c,4);\n    b ^= a; b -= mx_rotl32(a,14);\n    c ^= b; c -= mx_rotl32(b,24);\n    return c;\n}\n\n// Convert a 32 bit integer into a floating point number in [0,1]\nfloat mx_bits_to_01(uint bits)\n{\n    return float(bits) / float(uint(0xffffffff));\n}\n\nfloat mx_fade(float t)\n{\n   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nuint mx_hash_int(int x)\n{\n    uint len = 1u;\n    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;\n    return mx_bjfinal(seed+uint(x), seed, seed);\n}\n\nuint mx_hash_int(int x, int y)\n{\n    uint len = 2u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z)\n{\n    uint len = 3u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z, int xx)\n{\n    uint len = 4u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    mx_bjmix(a, b, c);\n    a += uint(xx);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z, int xx, int yy)\n{\n    uint len = 5u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    mx_bjmix(a, b, c);\n    a += uint(xx);\n    b += uint(yy);\n    return mx_bjfinal(a, b, c);\n}\n\nuvec3 mx_hash_vec3(int x, int y)\n{\n    uint h = mx_hash_int(x, y);\n    // we only need the low-order bits to be random, so split out\n    // the 32 bit result into 3 parts for each channel\n    uvec3 result;\n    result.x = (h      ) & 0xFFu;\n    result.y = (h >> 8 ) & 0xFFu;\n    result.z = (h >> 16) & 0xFFu;\n    return result;\n}\n\nuvec3 mx_hash_vec3(int x, int y, int z)\n{\n    uint h = mx_hash_int(x, y, z);\n    // we only need the low-order bits to be random, so split out\n    // the 32 bit result into 3 parts for each channel\n    uvec3 result;\n    result.x = (h      ) & 0xFFu;\n    result.y = (h >> 8 ) & 0xFFu;\n    result.z = (h >> 16) & 0xFFu;\n    return result;\n}\n\nfloat mx_perlin_noise_float(vec2 p)\n{\n    int X, Y;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float result = mx_bilerp(\n        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),\n        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),\n        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),\n        u, v);\n    return mx_gradient_scale2d(result);\n}\n\nfloat mx_perlin_noise_float(vec3 p)\n{\n    int X, Y, Z;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float fz = mx_floorfrac(p.z, Z);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float w = mx_fade(fz);\n    float result = mx_trilerp(\n        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\n        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\n        u, v, w);\n    return mx_gradient_scale3d(result);\n}\n\nvec3 mx_perlin_noise_vec3(vec2 p)\n{\n    int X, Y;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    vec3 result = mx_bilerp(\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),\n        u, v);\n    return mx_gradient_scale2d(result);\n}\n\nvec3 mx_perlin_noise_vec3(vec3 p)\n{\n    int X, Y, Z;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float fz = mx_floorfrac(p.z, Z);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float w = mx_fade(fz);\n    vec3 result = mx_trilerp(\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\n        u, v, w);\n    return mx_gradient_scale3d(result);\n}\n\nfloat mx_cell_noise_float(float p)\n{\n    int ix = mx_floor(p);\n    return mx_bits_to_01(mx_hash_int(ix));\n}\n\nfloat mx_cell_noise_float(vec2 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    return mx_bits_to_01(mx_hash_int(ix, iy));\n}\n\nfloat mx_cell_noise_float(vec3 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz));\n}\n\nfloat mx_cell_noise_float(vec4 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    int iw = mx_floor(p.w);\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\n}\n\nvec3 mx_cell_noise_vec3(float p)\n{\n    int ix = mx_floor(p);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, 0)),\n            mx_bits_to_01(mx_hash_int(ix, 1)),\n            mx_bits_to_01(mx_hash_int(ix, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec2 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec3 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec4 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    int iw = mx_floor(p.w);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))\n    );\n}\n\nfloat mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    float result = 0.0;\n    float amplitude = 1.0;\n    for (int i = 0;  i < octaves; ++i)\n    {\n        result += amplitude * mx_perlin_noise_float(p);\n        amplitude *= diminish;\n        p *= lacunarity;\n    }\n    return result;\n}\n\nvec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    vec3 result = vec3(0.0);\n    float amplitude = 1.0;\n    for (int i = 0;  i < octaves; ++i)\n    {\n        result += amplitude * mx_perlin_noise_vec3(p);\n        amplitude *= diminish;\n        p *= lacunarity;\n    }\n    return result;\n}\n\nvec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),\n                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));\n}\n\nvec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);\n    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);\n    return vec4(c, f);\n}\n\nfloat mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)\n{\n    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));\n    vec2  off = vec2(tmp.x, tmp.y);\n\n    off -= 0.5f;\n    off *= jitter;\n    off += 0.5f;\n\n    vec2 cellpos = vec2(float(x), float(y)) + off;\n    vec2 diff = cellpos - p;\n    if (metric == 2)\n        return abs(diff.x) + abs(diff.y);       // Manhattan distance\n    if (metric == 3)\n        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance\n    // Either Euclidian or Distance^2\n    return dot(diff, diff);\n}\n\nfloat mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)\n{\n    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));\n\n    off -= 0.5f;\n    off *= jitter;\n    off += 0.5f;\n\n    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;\n    vec3 diff = cellpos - p;\n    if (metric == 2)\n        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance\n    if (metric == 3)\n        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance\n    // Either Euclidian or Distance^2\n    return dot(diff, diff);\n}\n\nfloat mx_worley_noise_float(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            sqdist = min(sqdist, dist);\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    vec2 sqdist = vec2(1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            if (dist < sqdist.x)\n            {\n                sqdist.y = sqdist.x;\n                sqdist.x = dist;\n            }\n            else if (dist < sqdist.y)\n            {\n                sqdist.y = dist;\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            if (dist < sqdist.x)\n            {\n                sqdist.z = sqdist.y;\n                sqdist.y = sqdist.x;\n                sqdist.x = dist;\n            }\n            else if (dist < sqdist.y)\n            {\n                sqdist.z = sqdist.y;\n                sqdist.y = dist;\n            }\n            else if (dist < sqdist.z)\n            {\n                sqdist.z = dist;\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nfloat mx_worley_noise_float(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    float sqdist = 1e6f;\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                sqdist = min(sqdist, dist);\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    vec2 sqdist = vec2(1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                if (dist < sqdist.x)\n                {\n                    sqdist.y = sqdist.x;\n                    sqdist.x = dist;\n                }\n                else if (dist < sqdist.y)\n                {\n                    sqdist.y = dist;\n                }\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                if (dist < sqdist.x)\n                {\n                    sqdist.z = sqdist.y;\n                    sqdist.y = sqdist.x;\n                    sqdist.x = dist;\n                }\n                else if (dist < sqdist.y)\n                {\n                    sqdist.z = sqdist.y;\n                    sqdist.y = dist;\n                }\n                else if (dist < sqdist.z)\n                {\n                    sqdist.z = dist;\n                }\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}` );\n\nconst includes = [ mx_noise ];\n\nexport const mx_perlin_noise_float = fn( 'float mx_perlin_noise_float( any p )', includes );\nexport const mx_perlin_noise_vec2 = fn( 'vec2 mx_perlin_noise_vec2( any p )', includes );\nexport const mx_perlin_noise_vec3 = fn( 'vec3 mx_perlin_noise_vec3( any p )', includes );\n\nexport const mx_cell_noise_float = fn( 'float mx_cell_noise_float( vec3 p )', includes );\n\nexport const mx_worley_noise_float = fn( 'float mx_worley_noise_float( any p, float jitter, int metric )', includes );\nexport const mx_worley_noise_vec2 = fn( 'float mx_worley_noise_vec2( any p, float jitter, int metric )', includes );\nexport const mx_worley_noise_vec3 = fn( 'float mx_worley_noise_vec3( any p, float jitter, int metric )', includes );\n\nexport const mx_fractal_noise_float = fn( 'float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )', includes );\nexport const mx_fractal_noise_vec2 = fn( 'float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )', includes );\nexport const mx_fractal_noise_vec3 = fn( 'float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )', includes );\nexport const mx_fractal_noise_vec4 = fn( 'float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )', includes );\n", "import { fn } from '../../Nodes.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nexport const mx_hsvtorgb = fn( `vec3 mx_hsvtorgb(vec3 hsv)\n{\n    // Reference for this technique: Foley & van Dam\n    float h = hsv.x; float s = hsv.y; float v = hsv.z;\n    if (s < 0.0001f) {\n      return vec3 (v, v, v);\n    } else {\n        h = 6.0f * (h - floor(h));  // expand to [0..6)\n        int hi = int(trunc(h));\n        float f = h - float(hi);\n        float p = v * (1.0f-s);\n        float q = v * (1.0f-s*f);\n        float t = v * (1.0f-s*(1.0f-f));\n        if (hi == 0)\n            return vec3 (v, t, p);\n        else if (hi == 1)\n            return vec3 (q, v, p);\n        else if (hi == 2)\n            return vec3 (p, v, t);\n        else if (hi == 3)\n            return vec3 (p, q, v);\n        else if (hi == 4)\n            return vec3 (t, p, v);\n        return vec3 (v, p, q);\n    }\n}` );\n\nexport const mx_rgbtohsv = fn( `vec3 mx_rgbtohsv(vec3 c)\n{\n    // See Foley & van Dam\n    float r = c.x; float g = c.y; float b = c.z;\n    float mincomp = min (r, min(g, b));\n    float maxcomp = max (r, max(g, b));\n    float delta = maxcomp - mincomp;  // chroma\n    float h, s, v;\n    v = maxcomp;\n    if (maxcomp > 0.0f)\n        s = delta / maxcomp;\n    else s = 0.0f;\n    if (s <= 0.0f)\n        h = 0.0f;\n    else {\n        if      (r >= maxcomp) h = (g-b) / delta;\n        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;\n        else                   h = 4.0f + (r-g) / delta;\n        h *= (1.0f/6.0f);\n        if (h < 0.0f)\n            h += 1.0f;\n    }\n    return vec3(h, s, v);\n}` );\n", "import { code, fn } from '../../Nodes.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\nexport const mx_transform_color = code( `#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)\n\nvec3 mx_srgb_texture_to_lin_rec709(vec3 color)\n{\n    bvec3 isAbove = greaterThan(color, vec3(0.04045));\n    vec3 linSeg = color / 12.92;\n    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));\n    return mix(linSeg, powSeg, isAbove);\n}` );\n\nconst includes = [ mx_transform_color ];\n\nexport const mx_srgb_texture_to_lin_rec709 = fn( 'vec3 mx_srgb_texture_to_lin_rec709( vec3 color )', includes );\n", "import {\n\tmx_perlin_noise_float, mx_perlin_noise_vec2, mx_perlin_noise_vec3,\n\tmx_worley_noise_float as worley_noise_float, mx_worley_noise_vec2 as worley_noise_vec2, mx_worley_noise_vec3 as worley_noise_vec3,\n\tmx_cell_noise_float as cell_noise_float,\n\tmx_fractal_noise_float as fractal_noise_float, mx_fractal_noise_vec2 as fractal_noise_vec2, mx_fractal_noise_vec3 as fractal_noise_vec3, mx_fractal_noise_vec4 as fractal_noise_vec4\n} from './lib/mx_noise.js';\nimport { mx_hsvtorgb, mx_rgbtohsv } from './lib/mx_hsv.js';\nimport { mx_srgb_texture_to_lin_rec709 } from './lib/mx_transform_color.js';\nimport { nodeObject, float, vec2, vec4, add, sub, mul, mix, clamp, uv, length, smoothstep, dFdx, dFdy, sign, pow, abs, convert } from '../shadernode/ShaderNodeElements.js';\n\nexport const mx_aastep = ( threshold, value ) => {\n\n\tthreshold = float( threshold );\n\tvalue = float( value );\n\n\tconst afwidth = mul( length( vec2( dFdx( value ), dFdy( value ) ) ), 0.70710678118654757 );\n\n\treturn smoothstep( sub( threshold, afwidth ), add( threshold, afwidth ), value );\n\n};\n\nconst _ramp = ( a, b, uv, p ) => mix( a, b, clamp( nodeObject( uv )[ p ] ) );\nexport const mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );\nexport const mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );\n\nconst _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, nodeObject( uv )[ p ] ) );\nexport const mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );\nexport const mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );\n\nexport const mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => add( mul( uv_geo, uv_scale ), uv_offset );\n\nexport const mx_safepower = ( in1, in2 = 1 ) => mul( sign( in1 ), pow( abs( in1 ), in2 ) );\nexport const mx_contrast = ( input, amount = 1, pivot = .5 ) => add( mul( sub( input, pivot ), amount ), pivot );\n\nexport const mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => add( mul( amplitude, mx_perlin_noise_float( convert( texcoord, 'vec2|vec3' ) ) ), pivot );\nexport const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => add( mul( amplitude, mx_perlin_noise_vec2( convert( texcoord, 'vec2|vec3' ) ) ), pivot );\nexport const mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => add( mul( amplitude, mx_perlin_noise_vec3( convert( texcoord, 'vec2|vec3' ) ) ), pivot );\nexport const mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {\n\n\ttexcoord = convert( texcoord, 'vec2|vec3' ); // overloading type\n\n\tconst noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( add( texcoord, vec2( 19, 73 ) ) ) );\n\n\treturn add( mul( amplitude, noise_vec4 ), pivot );\n\n};\n\nexport const mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => worley_noise_float( convert( texcoord, 'vec2|vec3' ), jitter, 1 );\nexport const mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => worley_noise_vec2( convert( texcoord, 'vec2|vec3' ), jitter, 1 );\nexport const mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => worley_noise_vec3( convert( texcoord, 'vec2|vec3' ), jitter, 1 );\n\nexport const mx_cell_noise_float = ( texcoord = uv() ) => cell_noise_float( convert( texcoord, 'vec2|vec3' ) );\n\nexport const mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mul( fractal_noise_float( position, octaves, lacunarity, diminish ), amplitude );\nexport const mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mul( fractal_noise_vec2( position, octaves, lacunarity, diminish ), amplitude );\nexport const mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mul( fractal_noise_vec3( position, octaves, lacunarity, diminish ), amplitude );\nexport const mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mul( fractal_noise_vec4( position, octaves, lacunarity, diminish ), amplitude );\n\nexport { mx_hsvtorgb, mx_rgbtohsv, mx_srgb_texture_to_lin_rec709 };\n", "// core\nimport ArrayUniformNode from './core/ArrayUniformNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport BypassNode from './core/BypassNode.js';\nimport CacheNode from './core/CacheNode.js';\nimport CodeNode from './core/CodeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport ContextNode from './core/ContextNode.js';\nimport ExpressionNode from './core/ExpressionNode.js';\nimport FunctionCallNode from './core/FunctionCallNode.js';\nimport FunctionNode from './core/FunctionNode.js';\nimport InstanceIndexNode from './core/InstanceIndexNode.js';\nimport Node from './core/Node.js';\nimport NodeAttribute from './core/NodeAttribute.js';\nimport NodeBuilder from './core/NodeBuilder.js';\nimport NodeCache from './core/NodeCache.js';\nimport NodeCode from './core/NodeCode.js';\nimport NodeFrame from './core/NodeFrame.js';\nimport NodeFunctionInput from './core/NodeFunctionInput.js';\nimport NodeKeywords from './core/NodeKeywords.js';\nimport NodeUniform from './core/NodeUniform.js';\nimport NodeVar from './core/NodeVar.js';\nimport NodeVarying from './core/NodeVarying.js';\nimport PropertyNode from './core/PropertyNode.js';\nimport StackNode from './core/StackNode.js';\nimport TempNode from './core/TempNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport VarNode from './core/VarNode.js';\nimport VaryingNode from './core/VaryingNode.js';\n\n// accessors\nimport BitangentNode from './accessors/BitangentNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport CubeTextureNode from './accessors/CubeTextureNode.js';\nimport InstanceNode from './accessors/InstanceNode.js';\nimport MaterialNode from './accessors/MaterialNode.js';\nimport MaterialReferenceNode from './accessors/MaterialReferenceNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport ModelViewProjectionNode from './accessors/ModelViewProjectionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport Object3DNode from './accessors/Object3DNode.js';\nimport PointUVNode from './accessors/PointUVNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport ReferenceNode from './accessors/ReferenceNode.js';\nimport ReflectVectorNode from './accessors/ReflectVectorNode.js';\nimport SkinningNode from './accessors/SkinningNode.js';\nimport TangentNode from './accessors/TangentNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport UserDataNode from './accessors/UserDataNode.js';\n\n// geometry\nimport RangeNode from './geometry/RangeNode.js';\n\n// gpgpu\nimport ComputeNode from './gpgpu/ComputeNode.js';\n\n// display\nimport BlendModeNode from './display/BlendModeNode.js';\nimport ColorAdjustmentNode from './display/ColorAdjustmentNode.js';\nimport ColorSpaceNode from './display/ColorSpaceNode.js';\nimport FrontFacingNode from './display/FrontFacingNode.js';\nimport NormalMapNode from './display/NormalMapNode.js';\nimport PosterizeNode from './display/PosterizeNode.js';\nimport ToneMappingNode from './display/ToneMappingNode.js';\nimport ViewportNode from './display/ViewportNode.js';\n\n// math\nimport MathNode from './math/MathNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\n\n// lighting\nimport PointLightNode from './lighting/PointLightNode.js';\nimport DirectionalLightNode from './lighting/DirectionalLightNode.js';\nimport SpotLightNode from './lighting/SpotLightNode.js';\nimport AmbientLightNode from './lighting/AmbientLightNode.js';\nimport LightsNode from './lighting/LightsNode.js';\nimport LightingNode from './lighting/LightingNode.js';\nimport LightingContextNode from './lighting/LightingContextNode.js';\nimport HemisphereLightNode from './lighting/HemisphereLightNode.js';\nimport EnvironmentNode from './lighting/EnvironmentNode.js';\nimport AONode from './lighting/AONode.js';\nimport AnalyticLightNode from './lighting/AnalyticLightNode.js';\n\n// utils\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport EquirectUVNode from './utils/EquirectUVNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport MatcapUVNode from './utils/MatcapUVNode.js';\nimport MaxMipLevelNode from './utils/MaxMipLevelNode.js';\nimport OscNode from './utils/OscNode.js';\nimport RemapNode from './utils/RemapNode.js';\nimport RotateUVNode from './utils/RotateUVNode.js';\nimport SpecularMIPLevelNode from './utils/SpecularMIPLevelNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport SpriteSheetUVNode from './utils/SpriteSheetUVNode.js';\nimport TimerNode from './utils/TimerNode.js';\nimport TriplanarTexturesNode from './utils/TriplanarTexturesNode.js';\n\n// loaders\nimport NodeLoader from './loaders/NodeLoader.js';\nimport NodeObjectLoader from './loaders/NodeObjectLoader.js';\nimport NodeMaterialLoader from './loaders/NodeMaterialLoader.js';\n\n// parsers\nimport WGSLNodeParser from './parsers/WGSLNodeParser.js';\nimport GLSLNodeParser from './parsers/GLSLNodeParser.js';\n\n// procedural\nimport CheckerNode from './procedural/CheckerNode.js';\n\n// fog\nimport FogNode from './fog/FogNode.js';\nimport FogRangeNode from './fog/FogRangeNode.js';\nimport FogExp2Node from './fog/FogExp2Node.js';\n\n// core\nexport * from './core/constants.js';\n\n// materials\nexport * from './materials/Materials.js';\n\n// shader node\nexport * from './shadernode/ShaderNodeElements.js';\n\n// extensions\nexport * from './materialx/MaterialXNodes.js';\n\n// shader stages\nexport { defaultShaderStages } from './core/NodeBuilder.js';\n\nconst nodeLib = {\n\t// core\n\tArrayUniformNode,\n\tAttributeNode,\n\tBypassNode,\n\tCacheNode,\n\tCodeNode,\n\tContextNode,\n\tConstNode,\n\tExpressionNode,\n\tFunctionCallNode,\n\tFunctionNode,\n\tInstanceIndexNode,\n\tNode,\n\tNodeAttribute,\n\tNodeBuilder,\n\tNodeCache,\n\tNodeCode,\n\tNodeFrame,\n\tNodeFunctionInput,\n\tNodeKeywords,\n\tNodeUniform,\n\tNodeVar,\n\tNodeVarying,\n\tPropertyNode,\n\tStackNode,\n\tTempNode,\n\tUniformNode,\n\tVarNode,\n\tVaryingNode,\n\n\t// geometry\n\tRangeNode,\n\n\t// gpgpu\n\tComputeNode,\n\n\t// accessors\n\tBitangentNode,\n\tBufferNode,\n\tCameraNode,\n\tCubeTextureNode,\n\tInstanceNode,\n\tMaterialNode,\n\tMaterialReferenceNode,\n\tModelNode,\n\tModelViewProjectionNode,\n\tNormalNode,\n\tObject3DNode,\n\tPointUVNode,\n\tPositionNode,\n\tReferenceNode,\n\tReflectVectorNode,\n\tSkinningNode,\n\tTangentNode,\n\tTextureNode,\n\tUVNode,\n\tUserDataNode,\n\n\t// display\n\tBlendModeNode,\n\tColorAdjustmentNode,\n\tColorSpaceNode,\n\tFrontFacingNode,\n\tNormalMapNode,\n\tPosterizeNode,\n\tToneMappingNode,\n\tViewportNode,\n\n\t// math\n\tMathNode,\n\tOperatorNode,\n\tCondNode,\n\n\t// lighting\n\tPointLightNode,\n\tDirectionalLightNode,\n\tSpotLightNode,\n\tAmbientLightNode,\n\tLightsNode,\n\tLightingNode,\n\tLightingContextNode,\n\tHemisphereLightNode,\n\tEnvironmentNode,\n\tAONode,\n\tAnalyticLightNode,\n\n\t// utils\n\tArrayElementNode,\n\tConvertNode,\n\tEquirectUVNode,\n\tJoinNode,\n\tMatcapUVNode,\n\tMaxMipLevelNode,\n\tOscNode,\n\tRemapNode,\n\tRotateUVNode,\n\tSpecularMIPLevelNode,\n\tSplitNode,\n\tSpriteSheetUVNode,\n\tTimerNode,\n\tTriplanarTexturesNode,\n\n\t// procedural\n\tCheckerNode,\n\n\t// fog\n\tFogNode,\n\tFogRangeNode,\n\tFogExp2Node,\n\n\t// loaders\n\tNodeLoader,\n\tNodeObjectLoader,\n\tNodeMaterialLoader,\n\n\t// parsers\n\tWGSLNodeParser,\n\tGLSLNodeParser\n\n};\n\nexport const fromType = ( type ) => {\n\n\treturn new nodeLib[ type ]();\n\n};\n\nexport {\n\t// core\n\tArrayUniformNode,\n\tAttributeNode,\n\tBypassNode,\n\tCacheNode,\n\tCodeNode,\n\tContextNode,\n\tConstNode,\n\tExpressionNode,\n\tFunctionCallNode,\n\tFunctionNode,\n\tInstanceIndexNode,\n\tNode,\n\tNodeAttribute,\n\tNodeBuilder,\n\tNodeCache,\n\tNodeCode,\n\tNodeFrame,\n\tNodeFunctionInput,\n\tNodeKeywords,\n\tNodeUniform,\n\tNodeVar,\n\tNodeVarying,\n\tPropertyNode,\n\tStackNode,\n\tTempNode,\n\tUniformNode,\n\tVarNode,\n\tVaryingNode,\n\n\t// geometry\n\tRangeNode,\n\n\t// gpgpu\n\tComputeNode,\n\n\t// accessors\n\tBitangentNode,\n\tBufferNode,\n\tCameraNode,\n\tCubeTextureNode,\n\tInstanceNode,\n\tMaterialNode,\n\tMaterialReferenceNode,\n\tModelNode,\n\tModelViewProjectionNode,\n\tNormalNode,\n\tObject3DNode,\n\tPointUVNode,\n\tPositionNode,\n\tReferenceNode,\n\tReflectVectorNode,\n\tSkinningNode,\n\tTangentNode,\n\tTextureNode,\n\tUVNode,\n\tUserDataNode,\n\n\t// display\n\tBlendModeNode,\n\tColorAdjustmentNode,\n\tColorSpaceNode,\n\tFrontFacingNode,\n\tNormalMapNode,\n\tPosterizeNode,\n\tToneMappingNode,\n\tViewportNode,\n\n\t// math\n\tMathNode,\n\tOperatorNode,\n\tCondNode,\n\n\t// lighting\n\tPointLightNode,\n\tDirectionalLightNode,\n\tSpotLightNode,\n\tAmbientLightNode,\n\tLightsNode,\n\tLightingNode,\n\tLightingContextNode,\n\tHemisphereLightNode,\n\tEnvironmentNode,\n\tAONode,\n\tAnalyticLightNode,\n\n\t// utils\n\tArrayElementNode,\n\tConvertNode,\n\tEquirectUVNode,\n\tJoinNode,\n\tMatcapUVNode,\n\tMaxMipLevelNode,\n\tOscNode,\n\tRemapNode,\n\tRotateUVNode,\n\tSpecularMIPLevelNode,\n\tSplitNode,\n\tSpriteSheetUVNode,\n\tTimerNode,\n\tTriplanarTexturesNode,\n\n\t// procedural\n\tCheckerNode,\n\n\t// fog\n\tFogNode,\n\tFogRangeNode,\n\tFogExp2Node,\n\n\t// loaders\n\tNodeLoader,\n\tNodeObjectLoader,\n\tNodeMaterialLoader,\n\n\t// parsers\n\tWGSLNodeParser,\n\tGLSLNodeParser\n};\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": []
}
